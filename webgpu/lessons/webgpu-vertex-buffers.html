<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/webgpu-vertex-buffers.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Passing Vertex Data to Shaders">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-vertex-buffers_en.jpg">

<meta property="og:title" content="WebGPU Vertex Buffers">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-vertex-buffers_en.jpg">
<meta property="og:description" content="Passing Vertex Data to Shaders">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-vertex-buffers.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WebGPU Vertex Buffers">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-vertex-buffers.html">
<meta name="twitter:description" content="Passing Vertex Data to Shaders">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-vertex-buffers_en.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-vertex-buffers.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-vertex-buffers_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-vertex-buffers.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/webgpu-vertex-buffers.html",
      "inLanguage":"en",
      "name":"WebGPU Vertex Buffers",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-vertex-buffers.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WebGPU Vertex Buffers</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-vertex-buffers.html" selected="">English
    </option><option value="/webgpu/lessons/ja/webgpu-vertex-buffers.html">日本語
    </option><option value="/webgpu/lessons/ru/webgpu-vertex-buffers.html">Русский
    </option><option value="/webgpu/lessons/zh_cn/webgpu-vertex-buffers.html">简体中文
</option></select>


    <a href="#toc">Table of Contents</a>
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(160px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGPU Vertex Buffers</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>In <a href="webgpu-storage-buffers.html">the previous article</a> we put vertex
data in a storage buffer and indexed it using the builtin <code class="notranslate" translate="no">vertex_index</code>.
While that technique is growing in popularity, the traditional way to
provide vertex data to a vertex shader is via vertex buffers and
attributes.</p>
<p>Vertex buffers are just like any other WebGPU buffer. They hold data.
The difference is we don’t access them directly from the vertex shader.
Instead, we tell WebGPU what kind of data is in the buffer as well as
where it is and how it’s organized. It then pulls the data out of the
buffer and provides it for us.</p>
<p>Let’s take the last example from
<a href="webgpu-storage-buffers.html">the previous article</a>
and change it from using a storage buffer to using a vertex buffer.</p>
<p>The first thing to do is change the shader to get its vertex data
from a vertex buffer.</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct OurStruct {
  color: vec4f,
  offset: vec2f,
};

struct OtherStruct {
  scale: vec2f,
};

+struct Vertex {
+  @location(0) position: vec2f,
+};

struct VSOutput {
  @builtin(position) position: vec4f,
  @location(0) color: vec4f,
};

@group(0) @binding(0) var&lt;storage, read&gt; ourStructs: array&lt;OurStruct&gt;;
@group(0) @binding(1) var&lt;storage, read&gt; otherStructs: array&lt;OtherStruct&gt;;
-@group(0) @binding(2) var&lt;storage, read&gt; pos: array&lt;Vertex&gt;;

@vertex fn vs(
-  @builtin(vertex_index) vertexIndex : u32,
+  vert: Vertex,
  @builtin(instance_index) instanceIndex: u32
) -&gt; VSOutput {
  let otherStruct = otherStructs[instanceIndex];
  let ourStruct = ourStructs[instanceIndex];

  var vsOut: VSOutput;
  vsOut.position = vec4f(
-      pos[vertexIndex].position * otherStruct.scale + ourStruct.offset, 0.0, 1.0);
+      vert.position * otherStruct.scale + ourStruct.offset, 0.0, 1.0);
  vsOut.color = ourStruct.color;
  return vsOut;
}

...
</pre>
<p>As you can see, it’s a small change. We declared a struct <code class="notranslate" translate="no">Vertex</code> to define the data
for a vertex. The important part is declaring the position field with <code class="notranslate" translate="no">@location(0)</code></p>
<p>Then, when we create the render pipeline, we have to tell WebGPU how to get data
for <code class="notranslate" translate="no">@location0</code></p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: 'vertex buffer pipeline',
    layout: 'auto',
    vertex: {
      module,
      entryPoint: 'vs',
+      buffers: [
+        {
+          arrayStride: 2 * 4, // 2 floats, 4 bytes each
+          attributes: [
+            {shaderLocation: 0, offset: 0, format: 'float32x2'},  // position
+          ],
+        },
+      ],
    },
    fragment: {
      module,
      entryPoint: 'fs',
      targets: [{ format: presentationFormat }],
    },
  });
</pre>
<p>To the <a href="https://www.w3.org/TR/webgpu/#dictdef-gpuvertexstate"><code class="notranslate" translate="no">vertex</code></a> entry of the <a href="https://www.w3.org/TR/webgpu/#dictdef-gpurenderpipelinedescriptor"><code class="notranslate" translate="no">pipeline</code> descriptor</a>
we added a <code class="notranslate" translate="no">buffers</code> array which is used to describe how to pull data out of a 1 or more vertex buffers.
For the first and only buffer, we set an <code class="notranslate" translate="no">arrayStride</code> in number of bytes. a <em>stride</em> in this case is
how many bytes to get from the data for one vertex in the buffer, to the next vertex in the buffer.</p>
<div class="webgpu_center"><img src="resources/vertex-buffer-one.svg" style="width: 1024px;"></div>
<p>Since our data is <code class="notranslate" translate="no">vec2f</code>, which is two float32 numbers, we set the
<code class="notranslate" translate="no">arrayStride</code> to 8.</p>
<p>Next we define an array of attributes. We only have one. <code class="notranslate" translate="no">shaderLocation: 0</code>
corresponds to <code class="notranslate" translate="no">location(0)</code> in our <code class="notranslate" translate="no">Vertex</code> struct. <code class="notranslate" translate="no">offset: 0</code> says the data
for this attribute starts at byte 0 in the vertex buffer. Finally <code class="notranslate" translate="no">format: 'float32x2'</code> says we want WebGPU to pull the data out of the buffer as two 32bit
floating point numbers.</p>
<p>We need to change the usages of the buffer holding vertex data from <code class="notranslate" translate="no">STORAGE</code>
to <code class="notranslate" translate="no">VERTEX</code> and remove it from the bind group.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const vertexStorageBuffer = device.createBuffer({
-    label: 'storage buffer vertices',
-    size: vertexData.byteLength,
-    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
-  });
+  const vertexBuffer = device.createBuffer({
+    label: 'vertex buffer vertices',
+    size: vertexData.byteLength,
+    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
+  });

  const bindGroup = device.createBindGroup({
    label: 'bind group for objects',
    layout: pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: staticStorageBuffer }},
      { binding: 1, resource: { buffer: changingStorageBuffer }},
-      { binding: 2, resource: { buffer: vertexStorageBuffer }},
    ],
  });
</pre>
<p>And then at draw time we need to tell webgpu which vertex buffer to
use</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    pass.setPipeline(pipeline);
+    pass.setVertexBuffer(0, vertexBuffer);
</pre>
<p>The <code class="notranslate" translate="no">0</code> here corresponds to first element of the the render pipeline <code class="notranslate" translate="no">buffers</code>
array we specified above.</p>
<p>And we that we’ve switched from using a storage buffer for vertices to a
vertex buffer.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-vertex-buffers.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-vertex-buffers.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>The state when the draw command is executed would look something like this</p>
<div class="webgpu_center"><img src="resources/webgpu-draw-diagram-vertex-buffer.svg" style="width: 960px;"></div>
<p>The attribute <code class="notranslate" translate="no">format</code> field can be one of these types</p>
<div class="webgpu_center data-table">
  <style>
    .vertex-type td:nth-child(3),
    .vertex-type td:nth-child(4) {
      text-align: center;
    }
  </style>
  <div>
  <table class="vertex-type">
    <thead>
     <tr>
      <th>Vertex format</th>
      <th>Data type</th>
      <th>Components</th>
      <th>Byte size</th>
      <th>Example WGSL type</th>
     </tr>
    </thead>
    <tbody>
      <tr><td><code class="notranslate" translate="no">"uint8x2"</code></td><td>unsigned int </td><td>2 </td><td>2 </td><td><code class="notranslate" translate="no">vec2&lt;u32&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"uint8x4"</code></td><td>unsigned int </td><td>4 </td><td>4 </td><td><code class="notranslate" translate="no">vec4&lt;u32&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"sint8x2"</code></td><td>signed int </td><td>2 </td><td>2 </td><td><code class="notranslate" translate="no">vec2&lt;i32&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"sint8x4"</code></td><td>signed int </td><td>4 </td><td>4 </td><td><code class="notranslate" translate="no">vec4&lt;i32&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"unorm8x2"</code></td><td>unsigned normalized </td><td>2 </td><td>2 </td><td><code class="notranslate" translate="no">vec2&lt;f32&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"unorm8x4"</code></td><td>unsigned normalized </td><td>4 </td><td>4 </td><td><code class="notranslate" translate="no">vec4&lt;f32&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"snorm8x2"</code></td><td>signed normalized </td><td>2 </td><td>2 </td><td><code class="notranslate" translate="no">vec2&lt;f32&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"snorm8x4"</code></td><td>signed normalized </td><td>4 </td><td>4 </td><td><code class="notranslate" translate="no">vec4&lt;f32&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"uint16x2"</code></td><td>unsigned int </td><td>2 </td><td>4 </td><td><code class="notranslate" translate="no">vec2&lt;u32&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"uint16x4"</code></td><td>unsigned int </td><td>4 </td><td>8 </td><td><code class="notranslate" translate="no">vec4&lt;u32&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"sint16x2"</code></td><td>signed int </td><td>2 </td><td>4 </td><td><code class="notranslate" translate="no">vec2&lt;i32&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"sint16x4"</code></td><td>signed int </td><td>4 </td><td>8 </td><td><code class="notranslate" translate="no">vec4&lt;i32&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"unorm16x2"</code></td><td>unsigned normalized </td><td>2 </td><td>4 </td><td><code class="notranslate" translate="no">vec2&lt;f32&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"unorm16x4"</code></td><td>unsigned normalized </td><td>4 </td><td>8 </td><td><code class="notranslate" translate="no">vec4&lt;f32&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"snorm16x2"</code></td><td>signed normalized </td><td>2 </td><td>4 </td><td><code class="notranslate" translate="no">vec2&lt;f32&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"snorm16x4"</code></td><td>signed normalized </td><td>4 </td><td>8 </td><td><code class="notranslate" translate="no">vec4&lt;f32&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"float16x2"</code></td><td>float </td><td>2 </td><td>4 </td><td><code class="notranslate" translate="no">vec2&lt;f16&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"float16x4"</code></td><td>float </td><td>4 </td><td>8 </td><td><code class="notranslate" translate="no">vec4&lt;f16&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"float32"</code></td><td>float </td><td>1 </td><td>4 </td><td><code class="notranslate" translate="no">f32</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"float32x2"</code></td><td>float </td><td>2 </td><td>8 </td><td><code class="notranslate" translate="no">vec2&lt;f32&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"float32x3"</code></td><td>float </td><td>3 </td><td>12 </td><td><code class="notranslate" translate="no">vec3&lt;f32&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"float32x4"</code></td><td>float </td><td>4 </td><td>16 </td><td><code class="notranslate" translate="no">vec4&lt;f32&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"uint32"</code></td><td>unsigned int </td><td>1 </td><td>4 </td><td><code class="notranslate" translate="no">u32</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"uint32x2"</code></td><td>unsigned int </td><td>2 </td><td>8 </td><td><code class="notranslate" translate="no">vec2&lt;u32&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"uint32x3"</code></td><td>unsigned int </td><td>3 </td><td>12 </td><td><code class="notranslate" translate="no">vec3&lt;u32&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"uint32x4"</code></td><td>unsigned int </td><td>4 </td><td>16 </td><td><code class="notranslate" translate="no">vec4&lt;u32&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"sint32"</code></td><td>signed int </td><td>1 </td><td>4 </td><td><code class="notranslate" translate="no">i32</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"sint32x2"</code></td><td>signed int </td><td>2 </td><td>8 </td><td><code class="notranslate" translate="no">vec2&lt;i32&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"sint32x3"</code></td><td>signed int </td><td>3 </td><td>12 </td><td><code class="notranslate" translate="no">vec3&lt;i32&gt;</code></td></tr>
      <tr><td><code class="notranslate" translate="no">"sint32x4"</code></td><td>signed int </td><td>4 </td><td>16 </td><td><code class="notranslate" translate="no">vec4&lt;i32&gt;</code> </td></tr>
    </tbody>
  </table>
  </div>
</div>
<p>Let’s add a 2nd attribute for color. First let’s change the shader</p>
<pre class="prettyprint showlinemods notranslate lang-wgsl" translate="no">struct OurStruct {
  color: vec4f,
  offset: vec2f,
};

struct OtherStruct {
  scale: vec2f,
};

struct Vertex {
  @location(0) position: vec2f,
+  @location(1) color: vec3f,
};

struct VSOutput {
  @builtin(position) position: vec4f,
  @location(0) color: vec4f,
};

@group(0) @binding(0) var&lt;storage, read&gt; ourStructs: array&lt;OurStruct&gt;;
@group(0) @binding(1) var&lt;storage, read&gt; otherStructs: array&lt;OtherStruct&gt;;

@vertex fn vs(
  vert: Vertex,
  @builtin(instance_index) instanceIndex: u32
) -&gt; VSOutput {
  let otherStruct = otherStructs[instanceIndex];
  let ourStruct = ourStructs[instanceIndex];

  var vsOut: VSOutput;
  vsOut.position = vec4f(
      vert.position * otherStruct.scale + ourStruct.offset, 0.0, 1.0);
-  vsOut.color = ourStruct.color;
+  vsOut.color = ourStruct.color * vec4f(vert.color, 1);
  return vsOut;
}
</pre>
<p>Then we need to update the pipeline to describe how we’ll supply the data.
We’re going to interleave the data like this</p>
<div class="webgpu_center"><img src="resources/vertex-buffer-mixed.svg" style="width: 1024px;"></div>
<p>So, the <code class="notranslate" translate="no">arrayStride</code> need to be change to cover our new data and we need
to add the new attribute. It starts after two 32bit floating point numbers
so its <code class="notranslate" translate="no">offset</code> into the buffer is 8 bytes.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  const pipeline = device.createRenderPipeline({
    label: '2 attributes',
    layout: 'auto',
    vertex: {
      module,
      entryPoint: 'vs',
      buffers: [
        {
          arrayStride: (2 + 3) * 4, // (2 + 3) floats, 4 bytes each
          attributes: [
            {shaderLocation: 0, offset: 0, format: 'float32x2'}, // position
+            {shaderLocation: 1, offset: 8, format: 'float32x3'}, // color
          ],
        },
      ],
    },
    fragment: {
      module,
      entryPoint: 'fs',
      targets: [{ format: presentationFormat }],
    },
  });
</pre>
<p>We’ll update the circle vertex generation code to provide a dark color
for vertices on the outer edge of the circle and a light color for
the inner vertices.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function createCircleVertices({
  radius = 1,
  numSubdivisions = 24,
  innerRadius = 0,
  startAngle = 0,
  endAngle = Math.PI * 2,
} = {}) {
  // 2 triangles per subdivision, 3 verts per tri, 5 values (xyrgb) each.
  const numVertices = numSubdivisions * 3 * 2;
-  const vertexData = new Float32Array(numVertices * 2);
+  const vertexData = new Float32Array(numVertices * (2 + 3));

  let offset = 0;
-  const addVertex = (x, y, r, g, b) =&gt; {
+  const addVertex = (x, y, r, g, b) =&gt; {
    vertexData[offset++] = x;
    vertexData[offset++] = y;
+    vertexData[offset++] = r;
+    vertexData[offset++] = g;
+    vertexData[offset++] = b;
  };

+  const innerColor = [1, 1, 1];
+  const outerColor = [0.1, 0.1, 0.1];

  // 2 vertices per subdivision
  //
  // 0--1 4
  // | / /|
  // |/ / |
  // 2 3--5
  for (let i = 0; i &lt; numSubdivisions; ++i) {
    const angle1 = startAngle + (i + 0) * (endAngle - startAngle) / numSubdivisions;
    const angle2 = startAngle + (i + 1) * (endAngle - startAngle) / numSubdivisions;

    const c1 = Math.cos(angle1);
    const s1 = Math.sin(angle1);
    const c2 = Math.cos(angle2);
    const s2 = Math.sin(angle2);

    // first triangle
-    addVertex(c1 * radius, s1 * radius);
-    addVertex(c2 * radius, s2 * radius);
-    addVertex(c1 * innerRadius, s1 * innerRadius);
+    addVertex(c1 * radius, s1 * radius, ...outerColor);
+    addVertex(c2 * radius, s2 * radius, ...outerColor);
+    addVertex(c1 * innerRadius, s1 * innerRadius, ...innerColor);
-
-    // second triangle
-    addVertex(c1 * innerRadius, s1 * innerRadius);
-    addVertex(c2 * radius, s2 * radius);
-    addVertex(c2 * innerRadius, s2 * innerRadius);
+    addVertex(c1 * innerRadius, s1 * innerRadius, ...innerColor);
+    addVertex(c2 * radius, s2 * radius, ...outerColor);
+    addVertex(c2 * innerRadius, s2 * innerRadius, ...innerColor);
  }

  return {
    vertexData,
    numVertices,
  };
}
</pre>
<p>And with that we get shaded circles</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-vertex-buffers.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-vertex-buffers.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>Note that we don’t have to use a struct. This would work just as well</p>
<pre class="prettyprint showlinemods notranslate lang-WGSL" translate="no">@vertex fn vs(
-  vert: Vertex,
+  @location(0) position: vec2f,
+  @location(1) color: vec3f,
  @builtin(instance_index) instanceIndex: u32
) -&gt; VSOutput {
  let otherStruct = otherStructs[instanceIndex];
  let ourStruct = ourStructs[instanceIndex];

  var vsOut: VSOutput;
  vsOut.position = vec4f(
-      vert.position * otherStruct.scale + ourStruct.offset, 0.0, 1.0);
-  vsOut.color = ourStruct.color * vec4f(vert.color, 1);
+      position * otherStruct.scale + ourStruct.offset, 0.0, 1.0);
+  vsOut.color = ourStruct.color * vec4f(color, 1);
  return vsOut;
}
</pre>
<p>We could also supply the data in separate buffers. Nothing changes
in the shader. Instead we just update the pipeline</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">      buffers: [
        {
-          arrayStride: (2 + 3) * 4, // (2 + 3) floats, 4 bytes each
+          arrayStride: 2 * 4, // 2 floats, 4 bytes each
          attributes: [
            {shaderLocation: 0, offset: 0, format: 'float32x2'},  // position
-            {shaderLocation: 1, offset: 8, format: 'float32x3'},  // color
          ],
        },
+        {
+          arrayStride: 3 * 4, // 3 floats, 4 bytes each
+          attributes: [
+            {shaderLocation: 1, offset: 0, format: 'float32x3'},  // color
+          ],
+        },
      ],
</pre>
<p>And of course we need to separate the vertex data.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function createCircleVertices({
  radius = 1,
  numSubdivisions = 24,
  innerRadius = 0,
  startAngle = 0,
  endAngle = Math.PI * 2,
} = {}) {
  // 2 triangles per subdivision, 3 verts per tri, 5 values (xyrgb) each.
  const numVertices = numSubdivisions * 3 * 2;
-  const vertexData = new Float32Array(numVertices * (2 + 3));
-
-  let offset = 0;
-  const addVertex = (x, y, r, g, b) =&gt; {
-    vertexData[offset++] = x;
-    vertexData[offset++] = y;
-    vertexData[offset++] = r;
-    vertexData[offset++] = g;
-    vertexData[offset++] = b;
-  };
+  // 2 triangles per subdivision, 3 verts per tri, 5 values (xy) and (rgb) each.
+  const numVertices = numSubdivisions * 3 * 2;
+  const positionData = new Float32Array(numVertices * 2);
+  const colorData = new Float32Array(numVertices * 3);
+
+  let posOffset = 0;
+  let colorOffset = 0;
+  const addVertex = (x, y, r, g, b) =&gt; {
+    positionData[posOffset++] = x;
+    positionData[posOffset++] = y;
+    colorData[colorOffset++] = r;
+    colorData[colorOffset++] = g;
+    colorData[colorOffset++] = b;
+  };

  ...

  return {
-    vertexData,
+    positionData,
+    colorData,
    numVertices,
  };
}
</pre>
<p>and create 2 buffers instead of 1</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const { vertexData, numVertices } = createCircleVertices({
+  const { positionData, colorData, numVertices } = createCircleVertices({
    radius: 0.5,
    innerRadius: 0.25,
  });
-  const vertexBuffer = device.createBuffer({
-    label: 'vertex buffer vertices',
-    size: vertexData.byteLength,
-    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
-  });
-  device.queue.writeBuffer(vertexBuffer, 0, vertexData);
+  const positionBuffer = device.createBuffer({
+    label: 'position buffer',
+    size: positionData.byteLength,
+    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
+  });
+  device.queue.writeBuffer(positionBuffer, 0, positionData);
+  const colorBuffer = device.createBuffer({
+    label: 'color buffer',
+    size: colorData.byteLength,
+    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
+  });
+  device.queue.writeBuffer(colorBuffer, 0, colorData);
</pre>
<p>And then at render time we need to specify the both buffers</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    pass.setPipeline(pipeline);
-    pass.setVertexBuffer(0, vertexBuffer);
+    pass.setVertexBuffer(0, positionBuffer);
+    pass.setVertexBuffer(1, colorBuffer);
</pre>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-vertex-buffers-2-buffers.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-vertex-buffers-2-buffers.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>Like when we separate our first uniform buffer into 2 uniform buffers,
one reason you might want to separate vertex data into 2 buffers is if
some of the vertex data was static and other vertex data was updated
often.</p>
<h2 id="index-buffers"><a id="a-index-buffers"></a>Index Buffers</h2>
<p>One last thing to cover here are index buffers. Index buffers describe
the order to process and use the vertices.</p>
<p>You can think of <code class="notranslate" translate="no">draw</code> as going through the vertices in order</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">0, 1, 2, 3, 4, 5, .....
</pre>
<p>With an index buffer we can change that order.</p>
<p>We were creating 6 vertices per subdivision of the circle even though 2
of them were identical.</p>
<div class="webgpu_center"><img src="resources/vertices-non-indexed.svg" style="width: 400px"></div>  
<p>Now instead, we’ll only create 4 but then use indices to
use those 4 vertices 6 times by telling WebGPU to draw indices in this order</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no">0, 1, 2, 2, 1, 3, ...
</pre>
<div class="webgpu_center"><img src="resources/vertices-indexed.svg" style="width: 400px"></div>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function createCircleVertices({
  radius = 1,
  numSubdivisions = 24,
  innerRadius = 0,
  startAngle = 0,
  endAngle = Math.PI * 2,
} = {}) {
  // 2 triangles per subdivision, 3 verts per tri, 5 values (xyrgb) each.
  const numVertices = numSubdivisions * 3 * 2;
  const numVertices = (numSubdivisions + 1) * 2;
  const vertexData = new Float32Array(numVertices * (2 + 3));

  let offset = 0;
  const addVertex = (x, y, r, g, b) =&gt; {
    vertexData[offset++] = x;
    vertexData[offset++] = y;
    vertexData[offset++] = r;
    vertexData[offset++] = g;
    vertexData[offset++] = b;
  };

  const innerColor = [1, 1, 1];
  const outerColor = [0.1, 0.1, 0.1];

-  // 2 vertices per subdivision
-  //
-  // 0--1 4
-  // | / /|
-  // |/ / |
-  // 2 3--5
-  for (let i = 0; i &lt; numSubdivisions; ++i) {
-    const angle1 = startAngle + (i + 0) * (endAngle - startAngle) / numSubdivisions;
-    const angle2 = startAngle + (i + 1) * (endAngle - startAngle) / numSubdivisions;
-
-    const c1 = Math.cos(angle1);
-    const s1 = Math.sin(angle1);
-    const c2 = Math.cos(angle2);
-    const s2 = Math.sin(angle2);
-
-    // first triangle
-    addVertex(c1 * radius, s1 * radius, ...outerColor);
-    addVertex(c2 * radius, s2 * radius, ...outerColor);
-    addVertex(c1 * innerRadius, s1 * innerRadius, ...innerColor);
-
-    // second triangle
-    addVertex(c1 * innerRadius, s1 * innerRadius, ...innerColor);
-    addVertex(c2 * radius, s2 * radius, ...outerColor);
-    addVertex(c2 * innerRadius, s2 * innerRadius, ...innerColor);
-  }
+  // 2 vertices per subdivision
+  //
+  // 0  2  4  6  8 ...
+  //
+  // 1  3  5  7  9 ...
+  for (let i = 0; i &lt;= numSubdivisions; ++i) {
+    const angle = startAngle + (i + 0) * (endAngle - startAngle) / numSubdivisions;
+
+    const c1 = Math.cos(angle);
+    const s1 = Math.sin(angle);
+
+    addVertex(c1 * radius, s1 * radius, ...outerColor);
+    addVertex(c1 * innerRadius, s1 * innerRadius, ...innerColor);
+  }

+  const indexData = new Uint32Array(numSubdivisions * 6);
+  let ndx = 0;
+
+  // 0---2---4---...
+  // | //| //|
+  // |// |// |//
+  // 1---3-- 5---...
+  for (let i = 0; i &lt; numSubdivisions; ++i) {
+    const ndxOffset = i * 2;
+
+    // first triangle
+    indexData[ndx++] = ndxOffset;
+    indexData[ndx++] = ndxOffset + 1;
+    indexData[ndx++] = ndxOffset + 2;
+
+    // second triangle
+    indexData[ndx++] = ndxOffset + 2;
+    indexData[ndx++] = ndxOffset + 1;
+    indexData[ndx++] = ndxOffset + 3;
+  }

  return {
    vertexData,
+    indexData,
    numVertices: indexData.length,
  };
}
</pre>
<p>Then we need to create an index buffer</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-  const { vertexData, numVertices } = createCircleVertices({
+  const { vertexData, indexData, numVertices } = createCircleVertices({
    radius: 0.5,
    innerRadius: 0.25,
  });
  const vertexBuffer = device.createBuffer({
    label: 'vertex buffer vertices',
    size: vertexData.byteLength,
    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
  });
  device.queue.writeBuffer(vertexBuffer, 0, vertexData);
+  const indexBuffer = device.createBuffer({
+    label: 'index buffer',
+    size: indexData.byteLength,
+    usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
+  });
+  device.queue.writeBuffer(indexBuffer, 0, indexData);
</pre>
<p>Notice we changed the usage <code class="notranslate" translate="no">INDEX</code>.</p>
<p>Then finally at draw time we need to specify the index buffer</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    pass.setPipeline(pipeline);
    pass.setVertexBuffer(0, vertexBuffer);
+    pass.setIndexBuffer(indexBuffer, 'uint32');
</pre>
<p>Because our buffer contains 32bit unsigned integer indices
we need to pass <code class="notranslate" translate="no">'uint32'</code> here. We could also use 16 bit
unsigned indices in which case we’d pass in <code class="notranslate" translate="no">'uint16'</code>.</p>
<p>And we need to call <code class="notranslate" translate="no">drawIndexed</code> instead of <code class="notranslate" translate="no">draw</code></p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-    pass.draw(numVertices, kNumObjects);
+    pass.drawIndexed(numVertices, kNumObjects);
</pre>
<p>With that we saved some space (33%) and, potentially
a similar amount of processing when computing vertices
in the vertex shader.</p>
<p></p><div class="webgpu_example_container">
  <div><iframe class="webgpu_example" style=" " src="/webgpu/resources/editor.html?url=/webgpu/lessons/..%2Fwebgpu-vertex-buffers-index-buffer.html"></iframe></div>
  <a class="webgpu_center" href="/webgpu/lessons/../webgpu-vertex-buffers-index-buffer.html" target="_blank">click here to open in a separate window</a>
</div>

<p></p>
<p>Note that we could have also used an index buffer with the
storage buffer example from <a href="webgpu-storage-buffers.html">the previous article</a>.
In that case <code class="notranslate" translate="no">vertex_index</code> that’s passed in matches the index
from the index buffer.</p>
<p>Next up we’ll cover <a href="webgpu-textures.html">textures</a>.</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-vertex-buffers.html" selected="">English
    </option><option value="/webgpu/lessons/ja/webgpu-vertex-buffers.html">日本語
    </option><option value="/webgpu/lessons/ru/webgpu-vertex-buffers.html">Русский
    </option><option value="/webgpu/lessons/zh_cn/webgpu-vertex-buffers.html">简体中文
</option></select>


        <div id="toc">
          <ul>  <li>Basics</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgpu/lessons/webgpu-inter-stage-variables.html">Inter-stage Variables</a></li>
<li><a href="/webgpu/lessons/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-buffers.html">Storage Buffers</a></li>
<li><a href="/webgpu/lessons/webgpu-vertex-buffers.html">Vertex Buffers</a></li>
<li><a href="/webgpu/lessons/webgpu-textures.html">Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-importing-textures.html">Importing Images</a></li>
<li><a href="/webgpu/lessons/webgpu-constants.html">Constants</a></li>
<li><a href="/webgpu/lessons/webgpu-memory-layout.html">Data Memory Layout</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/webgpu-how-it-works.html">How It Works</a></li>
        </ul>
  <li>3D Math</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-translation.html">Translation</a></li>
<li><a href="/webgpu/lessons/webgpu-rotation.html">Rotation</a></li>
<li><a href="/webgpu/lessons/webgpu-scale.html">Scale</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-math.html">Matrix Math</a></li>
<li><a href="/webgpu/lessons/webgpu-orthographic-projection.html">Orthographic Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-perspective-projection.html">Perspective Projection</a></li>
<li><a href="/webgpu/lessons/webgpu-cameras.html">Cameras</a></li>
<li><a href="/webgpu/lessons/webgpu-matrix-stacks.html">Matrix Stacks</a></li>
<li><a href="/webgpu/lessons/webgpu-scene-graphs.html">Scene Graphs</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/webgpu-resources.html">Resources / References</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl-function-reference.html">WGSL Function Reference</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/gfxfundamentals/webgpufundamentals">github</a></li>
  <li><a href="/webgpu/lessons/resources/wgsl-offset-computer.html">WGSL Offset Computer</a></li>
  <li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
    <div>Questions? <a href="http://stackoverflow.com/questions/tagged/webgpu">Ask on stackoverflow</a>.</div>
    <div>
       <a href="https://github.com/gfxfundamentals/webgpufundamentals/issues/new?assignees=&amp;labels=suggested+topic&amp;template=suggest-topic.md&amp;title=%5BSUGGESTION%5D">Suggestion</a>?
       <a href="https://github.com/gfxfundamentals/webgpufundamentals/issues/new?assignees=&amp;labels=&amp;template=request.md&amp;title=">Request</a>?
       <a href="https://github.com/gfxfundamentals/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Issue</a>?
       <a href="https://github.com/gfxfundamentals/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Bug</a>?
    </div>
    <div class="lesson-comment-notes">
       Use <b>&lt;pre&gt;&lt;code&gt;</b>code goes here<b>&lt;/code&gt;&lt;/pre&gt;</b> for code blocks
    </div>
  

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WebGPU Vertex Buffers`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
      return;
  }

  function addScript(src, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }
  /*
  addScript('https://www.googletagmanager.com/gtag/js?id=UA-120733518-1', () => {
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-120733518-1');
  });
  */
}());
</script>






</body></html>