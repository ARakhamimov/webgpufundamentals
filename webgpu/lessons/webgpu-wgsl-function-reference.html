<!DOCTYPE html><!-- this file is auto-generated from webgpu/lessons/webgpu-wgsl-function-reference.md. Do not edited directly --><!--
Copyright 2023, GfxFundamentals Contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.

* Neither the name of GfxFundamentals nor the names of the
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


--><html lang="en"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="How to use Buffers">
<meta name="keywords" content="webgpu graphics">
<meta name="thumbnail" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-wgsl-function-reference_en.jpg">

<meta property="og:title" content="WGSL Function Reference">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-wgsl-function-reference_en.jpg">
<meta property="og:description" content="How to use Buffers">
<meta property="og:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-wgsl-function-reference.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgpufundamentals.org">
<meta name="twitter:title" content="WGSL Function Reference">
<meta name="twitter:url" content="https://webgpufundamentals.org/webgpu/lessons/webgpu-wgsl-function-reference.html">
<meta name="twitter:description" content="How to use Buffers">
<meta name="twitter:image:src" content="https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-wgsl-function-reference_en.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgpufundamentals.org/#website",
      "url":"https://webgpufundamentals.org/",
      "name":"webgpufundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-wgsl-function-reference.html#primaryimage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/screenshots/webgpu-wgsl-function-reference_en.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-wgsl-function-reference.html#webpage",
      "url":"https://webgpufundamentals.org/webgpu/lessons/webgpu-wgsl-function-reference.html",
      "inLanguage":"en",
      "name":"WGSL Function Reference",
      "keywords":"webgpu graphics programming",
      "isPartOf":{
        "@id":"https://webgpufundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgpufundamentals.org/webgpu/lessons/webgpu-wgsl-function-reference.html#primaryimage"
      }
    }
  ]
}
</script>

<title>WGSL Function Reference</title>
<link href="/webgpu/lessons/resources/webgpufundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="icon" href="/webgpu/lessons/resources/webgpufundamentals-icon.png">
<link rel="stylesheet" href="/webgpu/lessons/resources/lesson.css">
</head>
<body>
<div class="webgpu_navbar">
  <div>
    <select class="language">
    <option value="/webgpu/lessons/webgpu-wgsl-function-reference.html" selected="">English
</option></select>


    <a href="#toc">Table of Contents</a>
  </div>
</div>
<div class="webgpu_header">
  <h1><a href="/">webgpufundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgpufundamentals">Fix, Fork, Contribute <!--?xml version="1.0" encoding="UTF-8" standalone="no"?-->

<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"></path>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WGSL Function Reference</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <!-- this table is hackly generated here: https://jsgist.org/?src=6d9b87e1be0d1239167f115e59aa54b7 -->
<div class="webgpu-center center data-table">
<table><thead><tr><th>Function</th><th>Parameter Types</th><th>Description</th></tr></thead><tbody><tr class="data-table-head"><td id="bit-reinterp-builtin-functions" colspan="3"><a href="https://www.w3.org/TR/WGSL/#bit-reinterp-builtin-functions" target="_blank"></a>Bit Reinterpretation Built-in Functions</td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn bitcast&lt;T&gt;(e : T) -&gt; T </pre></td><td>T is a concrete numeric scalar or concrete numeric vector 
     </td><td id="bitcast-builtin"><a href="https://www.w3.org/TR/WGSL/#bitcast-builtin" target="_blank"></a>Identity transform.<br> Component-wise when <code class="notranslate" translate="no">T</code> is a vector.<br> The result is <code class="notranslate" translate="no">e</code>. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn bitcast&lt;T&gt;(e : S) -&gt; T </pre></td><td>S is i32, u32, or f32 T is not S and is i32, u32, or f32 
     </td><td id="bitcast-builtin"><a href="https://www.w3.org/TR/WGSL/#bitcast-builtin" target="_blank"></a>Reinterpretation of bits as <code class="notranslate" translate="no">T</code>.<br> The result is the reintepretation of bits in <code class="notranslate" translate="no">e</code> as a <code class="notranslate" translate="no">T</code> value. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn bitcast&lt;vecN&lt;T&gt;&gt;(e : vecN&lt;S&gt;) -&gt; T </pre></td><td>S is i32, u32, or f32 T is not S and is i32, u32, or f32 
     </td><td id="bitcast-builtin"><a href="https://www.w3.org/TR/WGSL/#bitcast-builtin" target="_blank"></a>Component-wise reinterpretation of bits as <code class="notranslate" translate="no">T</code>.<br> The result is the reintepretation of bits in <code class="notranslate" translate="no">e</code> as a <code class="notranslate" translate="no">vecN&lt;T&gt;</code> value. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn bitcast&lt;T&gt;(e : vec2&lt;f16&gt;) -&gt; T </pre></td><td>T is i32, u32, or f32 
     </td><td id="bitcast-builtin"><a href="https://www.w3.org/TR/WGSL/#bitcast-builtin" target="_blank"></a>Component-wise reinterpretation of bits as <code class="notranslate" translate="no">T</code>.<br> The result is the reintepretation of the 32 bits in <code class="notranslate" translate="no">e</code> as a <code class="notranslate" translate="no">T</code> value, following the internal layout rules. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn bitcast&lt;vec2&lt;T&gt;&gt;(e : vec4&lt;f16&gt;) -&gt; vec2&lt;T&gt; </pre></td><td>T is i32, u32, or f32 
     </td><td id="bitcast-builtin"><a href="https://www.w3.org/TR/WGSL/#bitcast-builtin" target="_blank"></a>Component-wise reinterpretation of bits as <code class="notranslate" translate="no">T</code>.<br> The result is the reintepretation of the 64 bits in <code class="notranslate" translate="no">e</code> as a <code class="notranslate" translate="no">T</code> value, following the internal layout rules. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn bitcast&lt;vec2&lt;f16&gt;&gt;(e : T) -&gt; vec2&lt;f16&gt; </pre></td><td>T is i32, u32, or f32 
     </td><td id="bitcast-builtin"><a href="https://www.w3.org/TR/WGSL/#bitcast-builtin" target="_blank"></a>Component-wise reinterpretation of bits as f16.<br> The result is the reintepretation of the 32 bits in <code class="notranslate" translate="no">e</code> as an f16 value, following the internal layout rules. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn bitcast&lt;vec4&lt;f16&gt;&gt;(e : vec2&lt;T&gt;) -&gt; vec4&lt;f16&gt; </pre></td><td>T is i32, u32, or f32 
     </td><td id="bitcast-builtin"><a href="https://www.w3.org/TR/WGSL/#bitcast-builtin" target="_blank"></a>Component-wise reinterpretation of bits as <code class="notranslate" translate="no">vec2&lt;f16&gt;</code>.<br> The result is the reintepretation of the 64 bits in <code class="notranslate" translate="no">e</code> as an f16 value, following the internal layout rules. 
   </td></tr><tr class="data-table-head"><td id="logical-builtin-functions" colspan="3"><a href="https://www.w3.org/TR/WGSL/#logical-builtin-functions" target="_blank"></a>Logical Built-in Functions</td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn all(e: vecN&lt;bool&gt;) -&gt; bool </pre></td><td></td><td id="all-builtin"><a href="https://www.w3.org/TR/WGSL/#all-builtin" target="_blank"></a>Returns true if each component of <code class="notranslate" translate="no">e</code> is true. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn all(e: bool) -&gt; bool </pre></td><td></td><td id="all-builtin"><a href="https://www.w3.org/TR/WGSL/#all-builtin" target="_blank"></a>Returns <code class="notranslate" translate="no">e</code>. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn any(e: vecN&lt;bool&gt;) -&gt; bool </pre></td><td></td><td id="any-builtin"><a href="https://www.w3.org/TR/WGSL/#any-builtin" target="_blank"></a>Returns true if any component of <code class="notranslate" translate="no">e</code> is true. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn any(e: bool) -&gt; bool </pre></td><td></td><td id="any-builtin"><a href="https://www.w3.org/TR/WGSL/#any-builtin" target="_blank"></a>Returns <code class="notranslate" translate="no">e</code>. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn select(f: T, t: T, cond: bool) -&gt; T </pre></td><td>T is scalar or vector 
     </td><td id="select-builtin"><a href="https://www.w3.org/TR/WGSL/#select-builtin" target="_blank"></a>Returns <code class="notranslate" translate="no">t</code> when <code class="notranslate" translate="no">cond</code> is true, and <code class="notranslate" translate="no">f</code> otherwise. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn select(f: vecN&lt;T&gt;, t: vecN&lt;T&gt;, cond: vecN&lt;bool&gt;) -&gt; vecN&lt;T&gt; </pre></td><td>T is scalar 
     </td><td id="select-builtin"><a href="https://www.w3.org/TR/WGSL/#select-builtin" target="_blank"></a>Component-wise selection. Result component <code class="notranslate" translate="no">i</code> is evaluated
        as <code class="notranslate" translate="no">select(f[i], t[i], cond[i])</code>. 
   </td></tr><tr class="data-table-head"><td id="array-builtin-functions" colspan="3"><a href="https://www.w3.org/TR/WGSL/#array-builtin-functions" target="_blank"></a>Array Built-in Functions</td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn arrayLength(p: ptr&lt;storage, array&lt;E&gt;, AM&gt;) -&gt; u32 </pre></td><td>E is an element type for a runtime-sized array, access mode AM is read or read_write 
     </td><td id="arrayLength-builtin"><a href="https://www.w3.org/TR/WGSL/#arrayLength-builtin" target="_blank"></a>
       Returns NRuntime, the number of elements in the runtime-sized array. 
       <p>See § 10.3.4 Buffer Binding Determines Runtime-Sized Array Element Count</p>
   </td></tr><tr class="data-table-head"><td id="numeric-builtin-functions" colspan="3"><a href="https://www.w3.org/TR/WGSL/#numeric-builtin-functions" target="_blank"></a>Numeric Built-in Functions</td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn abs(e: T ) -&gt; T </pre></td><td>S is AbstractInt, AbstractFloat, i32, u32, f32, or f16T is S, or vecN&lt;S&gt; 
     </td><td id="abs-float-builtin"><a href="https://www.w3.org/TR/WGSL/#abs-float-builtin" target="_blank"></a>
       The absolute value of <code class="notranslate" translate="no">e</code>. Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
       <p>If <code class="notranslate" translate="no">e</code> is a floating-point type, then the result is <code class="notranslate" translate="no">e</code> with a positive sign bit.
    If <code class="notranslate" translate="no">e</code> is an unsigned integer scalar type, then the result is <code class="notranslate" translate="no">e</code>.
    If <code class="notranslate" translate="no">e</code> is a signed integer scalar type and evaluates to the largest
    negative value, then the result is <code class="notranslate" translate="no">e</code>.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn acos(e: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="acos-builtin"><a href="https://www.w3.org/TR/WGSL/#acos-builtin" target="_blank"></a>
       <p class="note" role="note"><span class="marker">Note:</span> The result is not mathematically meaningful when <code class="notranslate" translate="no">abs(e)</code> &gt; 1.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn acosh(e: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="acosh-builtin"><a href="https://www.w3.org/TR/WGSL/#acosh-builtin" target="_blank"></a>
       <p class="note" role="note"><span class="marker">Note:</span> The result is not mathematically meaningful when <code class="notranslate" translate="no">e</code> &lt; 1.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn asin(e: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="asin-builtin"><a href="https://www.w3.org/TR/WGSL/#asin-builtin" target="_blank"></a>
       <p class="note" role="note"><span class="marker">Note:</span> The result is not mathematically meaningful when <code class="notranslate" translate="no">abs(e)</code> &gt; 1.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn asinh(e: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="asinh-builtin"><a href="https://www.w3.org/TR/WGSL/#asinh-builtin" target="_blank"></a>
       Returns the inverse hyperbolic sine (sinh<sup>-1</sup>) of <code class="notranslate" translate="no">e</code>, as a hyperbolic angle in radians.<br> That is, approximates <code class="notranslate" translate="no">x</code> such that <code class="notranslate" translate="no">sinh</code>(<code class="notranslate" translate="no">x</code>) = <code class="notranslate" translate="no">e</code>. 
       <p>Component-wise when <code class="notranslate" translate="no">T</code> is a vector.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn atan(e: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="atan-builtin"><a href="https://www.w3.org/TR/WGSL/#atan-builtin" target="_blank"></a>
       Returns the principal value, in radians, of the inverse tangent (tan<sup>-1</sup>) of <code class="notranslate" translate="no">e</code>.<br> That is, approximates <code class="notranslate" translate="no">x</code> with π/2 ≤ <code class="notranslate" translate="no">x</code> ≤ π/2, such that <code class="notranslate" translate="no">tan</code>(<code class="notranslate" translate="no">x</code>) = <code class="notranslate" translate="no">e</code>. 
       <p>Component-wise when <code class="notranslate" translate="no">T</code> is a vector.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn atanh(e: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="atanh-builtin"><a href="https://www.w3.org/TR/WGSL/#atanh-builtin" target="_blank"></a>
       <p class="note" role="note"><span class="marker">Note:</span> The result is not mathematically meaningful when <code class="notranslate" translate="no">abs(e)</code> ≥ 1.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn atan2(y: T, x: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="atan2-builtin"><a href="https://www.w3.org/TR/WGSL/#atan2-builtin" target="_blank"></a>
       Returns an angle, in radians, in the interval [-π, π] whose tangent is <code class="notranslate" translate="no">y</code>÷<code class="notranslate" translate="no">x</code>. 
       <p>The quadrant selected by the result depends on the signs of <code class="notranslate" translate="no">y</code> and <code class="notranslate" translate="no">x</code>.
    For example, the function may be implemented as:</p>
       <ul>
        <li data-md="">
         <p><code class="notranslate" translate="no">atan(y/x)</code> when <code class="notranslate" translate="no">x</code> &gt; 0</p>
        </li><li data-md="">
         <p><code class="notranslate" translate="no">atan(y/x)</code> + π when (<code class="notranslate" translate="no">x</code> &lt; 0) and (<code class="notranslate" translate="no">y</code> &gt; 0)</p>
        </li><li data-md="">
         <p><code class="notranslate" translate="no">atan(y/x)</code> - π when (<code class="notranslate" translate="no">x</code> &lt; 0) and (<code class="notranslate" translate="no">y</code> &lt; 0)</p>
       </li></ul>
       <p class="note" role="note"><span class="marker">Note:</span> atan2 is ill-defined when <code class="notranslate" translate="no">y/x</code> is ill-defined, at the origin (<code class="notranslate" translate="no">x</code>,<code class="notranslate" translate="no">y</code>) = (0,0), and when <code class="notranslate" translate="no">y</code> is non-normal or infinite.</p>
       <p>Component-wise when <code class="notranslate" translate="no">T</code> is a vector.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn ceil(e: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="ceil-builtin"><a href="https://www.w3.org/TR/WGSL/#ceil-builtin" target="_blank"></a>Returns the ceiling of <code class="notranslate" translate="no">e</code>. Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn clamp(e: T, low: T, high: T) -&gt; T </pre></td><td>S is AbstractInt, AbstractFloat, i32, u32, f32, or f16T is S, or vecN&lt;S&gt; 
     </td><td id="clamp"><a href="https://www.w3.org/TR/WGSL/#clamp" target="_blank"></a>
       Restricts the value of <code class="notranslate" translate="no">e</code> within a range. 
       <p>If <code class="notranslate" translate="no">T</code> is an integer type, then the result is <code class="notranslate" translate="no">min(max(e, low), high)</code>.</p>
       <p>If <code class="notranslate" translate="no">T</code> is a floating-point type, then the result is either <code class="notranslate" translate="no">min(max(e, low), high)</code>, or the median of the three values <code class="notranslate" translate="no">e</code>, <code class="notranslate" translate="no">low</code>, <code class="notranslate" translate="no">high</code>.</p>
       <p>Component-wise when <code class="notranslate" translate="no">T</code> is a vector.</p>
       <p>If <code class="notranslate" translate="no">low</code> is greater than <code class="notranslate" translate="no">high</code>, then:</p>
       <ul>
        <li data-md="">
         <p>It is a shader-creation error if <code class="notranslate" translate="no">low</code> and <code class="notranslate" translate="no">high</code> are const-expressions.</p>
        </li><li data-md="">
         <p>It is a pipeline-creation error if <code class="notranslate" translate="no">low</code> and <code class="notranslate" translate="no">high</code> are override-expressions.</p>
       </li></ul>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn cos(e: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="cos-builtin"><a href="https://www.w3.org/TR/WGSL/#cos-builtin" target="_blank"></a>Returns the cosine of <code class="notranslate" translate="no">e</code>, where <code class="notranslate" translate="no">e</code> is in radians. Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn cosh(arg: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="cosh-builtin"><a href="https://www.w3.org/TR/WGSL/#cosh-builtin" target="_blank"></a>
       Returns the hyperbolic cosine of <code class="notranslate" translate="no">arg</code>, where <code class="notranslate" translate="no">arg</code> is a hyperbolic angle in radians.
    Approximates the pure mathematical function (<em>e</em><sup>arg</sup> + <em>e</em><sup>−arg</sup>)÷2,
    but not necessarily computed that way. 
       <p>Component-wise when <code class="notranslate" translate="no">T</code> is a vector</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn countLeadingZeros(e: T) -&gt; T </pre></td><td>T is i32, u32, vecN&lt;i32&gt;, or vecN&lt;u32&gt; 
     </td><td id="countLeadingZeros-builtin"><a href="https://www.w3.org/TR/WGSL/#countLeadingZeros-builtin" target="_blank"></a>The number of consecutive 0 bits starting from the most significant bit
        of <code class="notranslate" translate="no">e</code>, when <code class="notranslate" translate="no">T</code> is a scalar type.<br> Component-wise when <code class="notranslate" translate="no">T</code> is a vector.<br> Also known as "clz" in some languages. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn countOneBits(e: T) -&gt; T </pre></td><td>T is i32, u32, vecN&lt;i32&gt;, or vecN&lt;u32&gt; 
     </td><td id="countOneBits-builtin"><a href="https://www.w3.org/TR/WGSL/#countOneBits-builtin" target="_blank"></a>The number of 1 bits in the representation of <code class="notranslate" translate="no">e</code>.<br> Also known as "population count".<br> Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn countTrailingZeros(e: T) -&gt; T </pre></td><td>T is i32, u32, vecN&lt;i32&gt;, or vecN&lt;u32&gt; 
     </td><td id="countTrailingZeros-builtin"><a href="https://www.w3.org/TR/WGSL/#countTrailingZeros-builtin" target="_blank"></a>The number of consecutive 0 bits starting from the least significant bit
        of <code class="notranslate" translate="no">e</code>, when <code class="notranslate" translate="no">T</code> is a scalar type.<br> Component-wise when <code class="notranslate" translate="no">T</code> is a vector.<br> Also known as "ctz" in some languages. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn cross(e1: vec3&lt;T&gt;, e2: vec3&lt;T&gt;) -&gt; vec3&lt;T&gt; </pre></td><td>T is AbstractFloat, f32, or f16 
     </td><td id="cross-builtin"><a href="https://www.w3.org/TR/WGSL/#cross-builtin" target="_blank"></a>Returns the cross product of <code class="notranslate" translate="no">e1</code> and <code class="notranslate" translate="no">e2</code>. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn degrees(e1: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="degrees-builtin"><a href="https://www.w3.org/TR/WGSL/#degrees-builtin" target="_blank"></a>Converts radians to degrees, approximating <code class="notranslate" translate="no">e1</code>&nbsp;×&nbsp;180&nbsp;÷&nbsp;π. Component-wise when <code class="notranslate" translate="no">T</code> is a vector 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn determinant(e: matCxC&lt;T&gt;) -&gt; T </pre></td><td>T is AbstractFloat, f32, or f16 
     </td><td id="determinant-builtin"><a href="https://www.w3.org/TR/WGSL/#determinant-builtin" target="_blank"></a>Returns the determinant of <code class="notranslate" translate="no">e</code>. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn distance(e1: T, e2: T) -&gt; S </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="distance-builtin"><a href="https://www.w3.org/TR/WGSL/#distance-builtin" target="_blank"></a>Returns the distance between <code class="notranslate" translate="no">e1</code> and <code class="notranslate" translate="no">e2</code> (e.g. <code class="notranslate" translate="no">length(e1 - e2)</code>). 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn dot(e1: vecN&lt;T&gt;, e2: vecN&lt;T&gt;) -&gt; T </pre></td><td>T is AbstractInt, AbstractFloat, i32, u32, f32, or f16 
     </td><td id="dot-builtin"><a href="https://www.w3.org/TR/WGSL/#dot-builtin" target="_blank"></a>Returns the dot product of <code class="notranslate" translate="no">e1</code> and <code class="notranslate" translate="no">e2</code>. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn exp(e1: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="exp-builtin"><a href="https://www.w3.org/TR/WGSL/#exp-builtin" target="_blank"></a>Returns the natural exponentiation of <code class="notranslate" translate="no">e1</code> (e.g. <code class="notranslate" translate="no">e</code><sup><code class="notranslate" translate="no">e1</code></sup>). Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn exp2(e: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="exp2-builtin"><a href="https://www.w3.org/TR/WGSL/#exp2-builtin" target="_blank"></a>Returns 2 raised to the power <code class="notranslate" translate="no">e</code> (e.g. <code class="notranslate" translate="no">2</code><sup><code class="notranslate" translate="no">e</code></sup>). Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn extractBits(e: T, offset: u32, count: u32) -&gt; T </pre></td><td>T is i32 or vecN&lt;i32&gt; 
     </td><td id="extractBits-signed-builtin"><a href="https://www.w3.org/TR/WGSL/#extractBits-signed-builtin" target="_blank"></a>
       Reads bits from an integer, with sign extension. 
       <p>When <code class="notranslate" translate="no">T</code> is a scalar type, then:</p>
       <ul>
        <li><code class="notranslate" translate="no">w</code> is the bit width of <code class="notranslate" translate="no">T</code> 
        </li><li><code class="notranslate" translate="no">o = min(offset, w)</code> 
        </li><li><code class="notranslate" translate="no">c = min(count, w - o)</code> 
        </li><li>The result is 0 if <code class="notranslate" translate="no">c</code> is 0. 
        </li><li>Otherwise, bits <code class="notranslate" translate="no">0..c - 1</code> of the result are copied from bits <code class="notranslate" translate="no">o..o + c - 1</code> of <code class="notranslate" translate="no">e</code>.
       Other bits of the result are the same as bit <code class="notranslate" translate="no">c - 1</code> of the result. 
       </li></ul>
        Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
       <p>If <code class="notranslate" translate="no">count</code> + <code class="notranslate" translate="no">offset</code> is greater than <code class="notranslate" translate="no">w</code>, then:</p>
       <ul>
        <li data-md="">
         <p>It is a shader-creation error if <code class="notranslate" translate="no">count</code> and <code class="notranslate" translate="no">offset</code> are const-expressions.</p>
        </li><li data-md="">
         <p>It is a pipeline-creation error if <code class="notranslate" translate="no">count</code> and <code class="notranslate" translate="no">offset</code> are override-expressions.</p>
       </li></ul>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn extractBits(e: T, offset: u32, count: u32) -&gt; T </pre></td><td>T is u32 or vecN&lt;u32&gt; 
     </td><td id="extractBits-unsigned-builtin"><a href="https://www.w3.org/TR/WGSL/#extractBits-unsigned-builtin" target="_blank"></a>
       Reads bits from an integer, without sign extension. 
       <p>When <code class="notranslate" translate="no">T</code> is a scalar type, then:</p>
       <ul>
        <li><code class="notranslate" translate="no">w</code> is the bit width of <code class="notranslate" translate="no">T</code> 
        </li><li><code class="notranslate" translate="no">o = min(offset, w)</code> 
        </li><li><code class="notranslate" translate="no">c = min(count, w - o)</code> 
        </li><li>The result is 0 if <code class="notranslate" translate="no">c</code> is 0. 
        </li><li>Otherwise, bits <code class="notranslate" translate="no">0..c - 1</code> of the result are copied from bits <code class="notranslate" translate="no">o..o + c - 1</code> of <code class="notranslate" translate="no">e</code>.
       Other bits of the result are 0. 
       </li></ul>
        Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
       <p>If <code class="notranslate" translate="no">count</code> + <code class="notranslate" translate="no">offset</code> is greater than <code class="notranslate" translate="no">w</code>, then:</p>
       <ul>
        <li data-md="">
         <p>It is a shader-creation error if <code class="notranslate" translate="no">count</code> and <code class="notranslate" translate="no">offset</code> are const-expressions.</p>
        </li><li data-md="">
         <p>It is a pipeline-creation error if <code class="notranslate" translate="no">count</code> and <code class="notranslate" translate="no">offset</code> are override-expressions.</p>
       </li></ul>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn faceForward(e1: T, e2: T, e3: T) -&gt; T </pre></td><td>T is vecN&lt;AbstractFloat&gt;, vecN&lt;f32&gt;, or vecN&lt;f16&gt; 
     </td><td id="faceForward-builtin"><a href="https://www.w3.org/TR/WGSL/#faceForward-builtin" target="_blank"></a>Returns <code class="notranslate" translate="no">e1</code> if <code class="notranslate" translate="no">dot(e2, e3)</code> is negative, and <code class="notranslate" translate="no">-e1</code> otherwise. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn firstLeadingBit(e: T) -&gt; T </pre></td><td>T is i32 or vecN&lt;i32&gt; 
     </td><td id="firstLeadingBit-signed-builtin"><a href="https://www.w3.org/TR/WGSL/#firstLeadingBit-signed-builtin" target="_blank"></a>
       <p class="note" role="note"><span class="marker">Note:</span> Since signed integers use twos-complement representation,
the sign bit appears in the most significant bit position.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn firstLeadingBit(e: T) -&gt; T </pre></td><td>T is u32 or vecN&lt;u32&gt; 
     </td><td id="firstLeadingBit-unsigned-builtin"><a href="https://www.w3.org/TR/WGSL/#firstLeadingBit-unsigned-builtin" target="_blank"></a>
       For scalar <code class="notranslate" translate="no">T</code>, the result is: 
       <ul>
        <li><code class="notranslate" translate="no">T(-1)</code> if <code class="notranslate" translate="no">e</code> is zero. 
        </li><li>Otherwise the position of the most significant 1
            bit in <code class="notranslate" translate="no">e</code>. 
       </li></ul>
        Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn firstTrailingBit(e: T) -&gt; T </pre></td><td>T is i32, u32, vecN&lt;i32&gt;, or vecN&lt;u32&gt; 
     </td><td id="firstTrailingBit-builtin"><a href="https://www.w3.org/TR/WGSL/#firstTrailingBit-builtin" target="_blank"></a>
       For scalar <code class="notranslate" translate="no">T</code>, the result is: 
       <ul>
        <li><code class="notranslate" translate="no">T(-1)</code> if <code class="notranslate" translate="no">e</code> is zero. 
        </li><li>Otherwise the position of the least significant 1
            bit in <code class="notranslate" translate="no">e</code>. 
       </li></ul>
        Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn floor(e: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="floor-builtin"><a href="https://www.w3.org/TR/WGSL/#floor-builtin" target="_blank"></a>Returns the floor of <code class="notranslate" translate="no">e</code>. Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn fma(e1: T, e2: T, e3: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="fma-builtin"><a href="https://www.w3.org/TR/WGSL/#fma-builtin" target="_blank"></a>
       Returns <code class="notranslate" translate="no">e1 * e2 + e3</code>. Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
       <p class="note" role="note"><span class="marker">Note:</span> The name <code class="notranslate" translate="no">fma</code> is short for "fused multiply add".</p>
       <p class="note" role="note"><span class="marker">Note:</span> The IEEE-754 <code class="notranslate" translate="no">fusedMultiplyAdd</code> operation computes the intermediate results
    as if with unbounded range and precision, and only the final result is rounded
    to the destination type.
    However, the § 14.6.1 Floating Point Accuracy rule for <code class="notranslate" translate="no">fma</code> allows an implementation
    which performs an ordinary multiply to the target type followed by an ordinary addition.
    In this case the intermediate values may overflow or lose accuracy, and the overall
    operation is not "fused" at all.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn fract(e: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="fract-builtin"><a href="https://www.w3.org/TR/WGSL/#fract-builtin" target="_blank"></a>
       <p class="note" role="note"><span class="marker">Note:</span> Valid results are in the closed interval [0, 1.0].
For example, if <code class="notranslate" translate="no">e</code> is a very small negative number, then <code class="notranslate" translate="no">fract(e)</code> may be 1.0.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn frexp(e: T) -&gt; __frexp_result_f32 </pre></td><td>T is f32 
     </td><td id="frexp-builtin"><a href="https://www.w3.org/TR/WGSL/#frexp-builtin" target="_blank"></a>
       <p class="note" role="note"><span class="marker">Note:</span> A value cannot be explicitly declared with the type <code class="notranslate" translate="no">__frexp_result_f32</code>,
but a value may infer the type.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn frexp(e: T) -&gt; __frexp_result_f16 </pre></td><td>T is f16 
     </td><td id="frexp-builtin"><a href="https://www.w3.org/TR/WGSL/#frexp-builtin" target="_blank"></a>
       <p class="note" role="note"><span class="marker">Note:</span> A value cannot be explicitly declared with the type <code class="notranslate" translate="no">__frexp_result_f16</code>,
but a value may infer the type.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn frexp(e: T) -&gt; __frexp_result_abstract </pre></td><td>T is AbstractFloat 
     </td><td id="frexp-builtin"><a href="https://www.w3.org/TR/WGSL/#frexp-builtin" target="_blank"></a>
       <p class="note" role="note"><span class="marker">Note:</span> A value cannot be explicitly declared with the type <code class="notranslate" translate="no">__frexp_result_abstract</code>,
but a value may infer the type.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn frexp(e: T) -&gt; __frexp_result_vecN_f32 </pre></td><td>T is vecN&lt;f32&gt; 
     </td><td id="frexp-builtin"><a href="https://www.w3.org/TR/WGSL/#frexp-builtin" target="_blank"></a>
       <p class="note" role="note"><span class="marker">Note:</span> A value cannot be explicitly declared with the type <code class="notranslate" translate="no">__frexp_result_vecN_f32</code>,
but a value may infer the type.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn frexp(e: T) -&gt; __frexp_result_vecN_f16 </pre></td><td>T is vecN&lt;f16&gt; 
     </td><td id="frexp-builtin"><a href="https://www.w3.org/TR/WGSL/#frexp-builtin" target="_blank"></a>
       <p class="note" role="note"><span class="marker">Note:</span> A value cannot be explicitly declared with the type <code class="notranslate" translate="no">__frexp_result_vecN_f16</code>,
but a value may infer the type.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn frexp(e: T) -&gt; __frexp_result_vecN_abstract </pre></td><td>T is vecN&lt;AbstractFloat&gt; 
     </td><td id="frexp-builtin"><a href="https://www.w3.org/TR/WGSL/#frexp-builtin" target="_blank"></a>
       <p class="note" role="note"><span class="marker">Note:</span> A value cannot be explicitly declared with the type <code class="notranslate" translate="no">__frexp_result_vecN_abstract</code>,
but a value may infer the type.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn insertBits(e: T, newbits: T, offset: u32, count: u32) -&gt; T </pre></td><td>T is i32, u32, vecN&lt;i32&gt;, or vecN&lt;u32&gt; 
     </td><td id="insertBits-builtin"><a href="https://www.w3.org/TR/WGSL/#insertBits-builtin" target="_blank"></a>
       Sets bits in an integer. 
       <p>When <code class="notranslate" translate="no">T</code> is a scalar type, then:</p>
       <ul>
        <li><code class="notranslate" translate="no">w</code> is the bit width of <code class="notranslate" translate="no">T</code> 
        </li><li><code class="notranslate" translate="no">o = min(offset, w)</code> 
        </li><li><code class="notranslate" translate="no">c = min(count, w - o)</code> 
        </li><li>The result is <code class="notranslate" translate="no">e</code> if <code class="notranslate" translate="no">c</code> is 0. 
        </li><li>Otherwise,
       bits <code class="notranslate" translate="no">o..o + c - 1</code> of the result are copied from bits <code class="notranslate" translate="no">0..c - 1</code> of <code class="notranslate" translate="no">newbits</code>.
       Other bits of the result are copied from <code class="notranslate" translate="no">e</code>. 
       </li></ul>
        Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
       <p>If <code class="notranslate" translate="no">count</code> + <code class="notranslate" translate="no">offset</code> is greater than <code class="notranslate" translate="no">w</code>, then:</p>
       <ul>
        <li data-md="">
         <p>It is a shader-creation error if <code class="notranslate" translate="no">count</code> and <code class="notranslate" translate="no">offset</code> are const-expressions.</p>
        </li><li data-md="">
         <p>It is a pipeline-creation error if <code class="notranslate" translate="no">count</code> and <code class="notranslate" translate="no">offset</code> are override-expressions.</p>
       </li></ul>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn inverseSqrt(e: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="inverseSqrt-builtin"><a href="https://www.w3.org/TR/WGSL/#inverseSqrt-builtin" target="_blank"></a>
       <p class="note" role="note"><span class="marker">Note:</span> The result is not mathematically meaningful if <code class="notranslate" translate="no">e</code> ≤ 0.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn ldexp(e1: T, e2: I) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; I is AbstractInt, i32, vecN&lt;AbstractInt&gt;, or vecN&lt;i32&gt; I is a vector if and only if T is a vector I is concrete if and only if T is a concrete 
     </td><td id="ldexp-builtin"><a href="https://www.w3.org/TR/WGSL/#ldexp-builtin" target="_blank"></a>
       Returns <code class="notranslate" translate="no">e1 * 2</code><sup><code class="notranslate" translate="no">e2</code></sup>, except: 
       <ul>
        <li data-md="">
         <p>The result may be zero if <code class="notranslate" translate="no">e2</code> + <em>bias</em> ≤ 0.</p>
        </li><li data-md="">
         <p>If <code class="notranslate" translate="no">e2</code> &gt; <em>bias</em> + 1</p>
         <ul>
          <li data-md="">
           <p>It is a shader-creation error if <code class="notranslate" translate="no">e2</code> is a const-expression.</p>
          </li><li data-md="">
           <p>It is a pipeline-creation error if <code class="notranslate" translate="no">e2</code> is an override-expression.</p>
          </li><li data-md="">
           <p>Otherwise the result is an indeterminate value for <code class="notranslate" translate="no">T</code>.</p>
         </li></ul>
       </li></ul>
       <p>Here, <em>bias</em> is the exponent bias of the floating point format:</p>
       <ul>
        <li data-md="">
         <p>15 for <code class="notranslate" translate="no">f16</code></p>
        </li><li data-md="">
         <p>127 for <code class="notranslate" translate="no">f32</code></p>
        </li><li data-md="">
         <p>1023 for AbstractFloat, when AbstractFloat is IEEE-754 binary64</p>
       </li></ul>
       <p>If <code class="notranslate" translate="no">x</code> is zero or a finite normal value for its type, then:</p>
       <blockquote> x = ldexp(frexp(x).fract, frexp(x).exp) </blockquote>
       <p>Component-wise when <code class="notranslate" translate="no">T</code> is a vector.</p>
       <p class="note" role="note"><span class="marker">Note:</span> A mnemonic for the name <code class="notranslate" translate="no">ldexp</code> is "load exponent".
    The name may have been taken from the corresponding instruction in the floating point unit of
    the PDP-11.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn length(e: T) -&gt; S </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="length-builtin"><a href="https://www.w3.org/TR/WGSL/#length-builtin" target="_blank"></a>
       Returns the length of <code class="notranslate" translate="no">e</code>.<br> Evaluates to the absolute value of <code class="notranslate" translate="no">e</code> if <code class="notranslate" translate="no">T</code> is scalar.<br> Evaluates to <code class="notranslate" translate="no">sqrt(e[0]</code><sup><code class="notranslate" translate="no">2</code></sup> <code class="notranslate" translate="no">+ e[1]</code><sup><code class="notranslate" translate="no">2</code></sup> <code class="notranslate" translate="no">+ ...)</code> if <code class="notranslate" translate="no">T</code> is a vector type. 
       <p class="note" role="note"><span class="marker">Note:</span> The scalar case may be evaluated as <code class="notranslate" translate="no">sqrt(e * e)</code>,
        which may unnecessarily overflow or lose accuracy.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn log(e: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="log-builtin"><a href="https://www.w3.org/TR/WGSL/#log-builtin" target="_blank"></a>
       <p class="note" role="note"><span class="marker">Note:</span> The result is not mathematically meaningful if <code class="notranslate" translate="no">e</code> &lt; 0.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn log2(e: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="log2-builtin"><a href="https://www.w3.org/TR/WGSL/#log2-builtin" target="_blank"></a>
       <p class="note" role="note"><span class="marker">Note:</span> The result is not mathematically meaningful if <code class="notranslate" translate="no">e</code> &lt; 0.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn max(e1: T, e2: T) -&gt; T </pre></td><td>S is AbstractInt, AbstractFloat, i32, u32, f32, or f16T is S, or vecN&lt;S&gt; 
     </td><td id="max-float-builtin"><a href="https://www.w3.org/TR/WGSL/#max-float-builtin" target="_blank"></a>
       Returns <code class="notranslate" translate="no">e2</code> if <code class="notranslate" translate="no">e1</code> is less than <code class="notranslate" translate="no">e2</code>, and <code class="notranslate" translate="no">e1</code> otherwise. Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
       <p>If <code class="notranslate" translate="no">e1</code> and <code class="notranslate" translate="no">e2</code> are floating-point values, then:</p>
       <ul>
        <li data-md="">
         <p>If both <code class="notranslate" translate="no">e1</code> and <code class="notranslate" translate="no">e2</code> are denormalized, then the result may be <em>either</em> value.</p>
        </li><li data-md="">
         <p>If one operand is a NaN, the other is returned.</p>
        </li><li data-md="">
         <p>If both operands are NaNs, a NaN is returned.</p>
       </li></ul>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn min(e1: T, e2: T) -&gt; T </pre></td><td>S is AbstractInt, AbstractFloat, i32, u32, f32, or f16T is S, or vecN&lt;S&gt; 
     </td><td id="min-float-builtin"><a href="https://www.w3.org/TR/WGSL/#min-float-builtin" target="_blank"></a>
       Returns <code class="notranslate" translate="no">e2</code> if <code class="notranslate" translate="no">e2</code> is less than <code class="notranslate" translate="no">e1</code>, and <code class="notranslate" translate="no">e1</code> otherwise. Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
       <p>If <code class="notranslate" translate="no">e1</code> and <code class="notranslate" translate="no">e2</code> are floating-point values, then:</p>
       <ul>
        <li data-md="">
         <p>If both <code class="notranslate" translate="no">e1</code> and <code class="notranslate" translate="no">e2</code> are denormalized, then the result may be <em>either</em> value.</p>
        </li><li data-md="">
         <p>If one operand is a NaN, the other is returned.</p>
        </li><li data-md="">
         <p>If both operands are NaNs, a NaN is returned.</p>
       </li></ul>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn mix(e1: T, e2: T, e3: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="mix-builtin"><a href="https://www.w3.org/TR/WGSL/#mix-builtin" target="_blank"></a>Returns the linear blend of <code class="notranslate" translate="no">e1</code> and <code class="notranslate" translate="no">e2</code> (e.g. <code class="notranslate" translate="no">e1 * (1 - e3) + e2 * e3</code>). Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn mix(e1: T2, e2: T2, e3: T) -&gt; T2 </pre></td><td>T is AbstractFloat, f32, or f16 T2 is vecN&lt;T&gt; 
     </td><td id="mix-builtin"><a href="https://www.w3.org/TR/WGSL/#mix-builtin" target="_blank"></a>Returns the component-wise linear blend of <code class="notranslate" translate="no">e1</code> and <code class="notranslate" translate="no">e2</code>,
        using scalar blending factor <code class="notranslate" translate="no">e3</code> for each component.<br> Same as <code class="notranslate" translate="no">mix(e1, e2, T2(e3))</code>. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn modf(e: T) -&gt; __modf_result_f32 </pre></td><td>T is f32 
     </td><td id="modf-builtin"><a href="https://www.w3.org/TR/WGSL/#modf-builtin" target="_blank"></a>
       <p class="note" role="note"><span class="marker">Note:</span> A value cannot be explicitly declared with the type <code class="notranslate" translate="no">__modf_result_f32</code>,
but a value may infer the type.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn modf(e: T) -&gt; __modf_result_f16 </pre></td><td>T is f16 
     </td><td id="modf-builtin"><a href="https://www.w3.org/TR/WGSL/#modf-builtin" target="_blank"></a>
       <p class="note" role="note"><span class="marker">Note:</span> A value cannot be explicitly declared with the type <code class="notranslate" translate="no">__modf_result_f16</code>,
but a value may infer the type.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn modf(e: T) -&gt; __modf_result_abstract </pre></td><td>T is AbstractFloat 
     </td><td id="modf-builtin"><a href="https://www.w3.org/TR/WGSL/#modf-builtin" target="_blank"></a>
       <p class="note" role="note"><span class="marker">Note:</span> A value cannot be explicitly declared with the type <code class="notranslate" translate="no">__modf_result_abstract</code>,
but a value may infer the type.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn modf(e: T) -&gt; __modf_result_vecN_f32 </pre></td><td>T is vecN&lt;f32&gt; 
     </td><td id="modf-builtin"><a href="https://www.w3.org/TR/WGSL/#modf-builtin" target="_blank"></a>
       <p class="note" role="note"><span class="marker">Note:</span> A value cannot be explicitly declared with the type <code class="notranslate" translate="no">__modf_result_vecN_f32</code>,
but a value may infer the type.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn modf(e: T) -&gt; __modf_result_vecN_f16 </pre></td><td>T is vecN&lt;f16&gt; 
     </td><td id="modf-builtin"><a href="https://www.w3.org/TR/WGSL/#modf-builtin" target="_blank"></a>
       <p class="note" role="note"><span class="marker">Note:</span> A value cannot be explicitly declared with the type <code class="notranslate" translate="no">__modf_result_vecN_f16</code>,
but a value may infer the type.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn modf(e: T) -&gt; __modf_result_vecN_abstract </pre></td><td>T is vecN&lt;AbstractFloat&gt; 
     </td><td id="modf-builtin"><a href="https://www.w3.org/TR/WGSL/#modf-builtin" target="_blank"></a>
       <p class="note" role="note"><span class="marker">Note:</span> A value cannot be explicitly declared with the type <code class="notranslate" translate="no">__modf_result_vecN_abstract</code>,
but a value may infer the type.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn normalize(e: vecN&lt;T&gt; ) -&gt; vecN&lt;T&gt; </pre></td><td>T is AbstractFloat, f32, or f16 
     </td><td id="normalize-builtin"><a href="https://www.w3.org/TR/WGSL/#normalize-builtin" target="_blank"></a>Returns a unit vector in the same direction as <code class="notranslate" translate="no">e</code>. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn pow(e1: T, e2: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="pow-builtin"><a href="https://www.w3.org/TR/WGSL/#pow-builtin" target="_blank"></a>Returns <code class="notranslate" translate="no">e1</code> raised to the power <code class="notranslate" translate="no">e2</code>. Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn quantizeToF16(e: T) -&gt; T </pre></td><td>T is f32 or vecN&lt;f32&gt; 
     </td><td id="quantizeToF16-builtin"><a href="https://www.w3.org/TR/WGSL/#quantizeToF16-builtin" target="_blank"></a>
       <p class="note" role="note"><span class="marker">Note:</span> The vec2&lt;f32&gt; case is the same as <code class="notranslate" translate="no">unpack2x16float(pack2x16float(e))</code>.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn radians(e1: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="radians-builtin"><a href="https://www.w3.org/TR/WGSL/#radians-builtin" target="_blank"></a>Converts degrees to radians, approximating <code class="notranslate" translate="no">e1</code>&nbsp;×&nbsp;π&nbsp;÷&nbsp;180. Component-wise when <code class="notranslate" translate="no">T</code> is a vector 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn reflect(e1: T, e2: T) -&gt; T </pre></td><td>T is vecN&lt;AbstractFloat&gt;, vecN&lt;f32&gt;, or vecN&lt;f16&gt; 
     </td><td id="reflect-builtin"><a href="https://www.w3.org/TR/WGSL/#reflect-builtin" target="_blank"></a>For the incident vector <code class="notranslate" translate="no">e1</code> and surface orientation <code class="notranslate" translate="no">e2</code>, returns the reflection direction <code class="notranslate" translate="no">e1 - 2 * dot(e2, e1) * e2</code>. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn refract(e1: T, e2: T, e3: I) -&gt; T </pre></td><td>T is vecN&lt;I&gt; I is AbstractFloat, f32, or f16 
     </td><td id="refract-builtin"><a href="https://www.w3.org/TR/WGSL/#refract-builtin" target="_blank"></a>For the incident vector <code class="notranslate" translate="no">e1</code> and surface normal <code class="notranslate" translate="no">e2</code>, and the ratio of
    indices of refraction <code class="notranslate" translate="no">e3</code>,
    let <code class="notranslate" translate="no">k = 1.0 - e3 * e3 * (1.0 - dot(e2, e1) * dot(e2, e1))</code>.
    If <code class="notranslate" translate="no">k &lt; 0.0</code>, returns the refraction vector 0.0, otherwise return the refraction vector <code class="notranslate" translate="no">e3 * e1 - (e3 * dot(e2, e1) + sqrt(k)) * e2</code>. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn reverseBits(e: T) -&gt; T </pre></td><td>T is i32, u32, vecN&lt;i32&gt;, or vecN&lt;u32&gt; 
     </td><td id="reverseBits-builtin"><a href="https://www.w3.org/TR/WGSL/#reverseBits-builtin" target="_blank"></a>Reverses the bits in <code class="notranslate" translate="no">e</code>:  The bit at position <code class="notranslate" translate="no">k</code> of the result equals the
        bit at position <code class="notranslate" translate="no">31 -k</code> of <code class="notranslate" translate="no">e</code>.<br> Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn round(e: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="round-builtin"><a href="https://www.w3.org/TR/WGSL/#round-builtin" target="_blank"></a>Result is the integer <code class="notranslate" translate="no">k</code> nearest to <code class="notranslate" translate="no">e</code>, as a floating point value.<br> When <code class="notranslate" translate="no">e</code> lies halfway between integers <code class="notranslate" translate="no">k</code> and <code class="notranslate" translate="no">k + 1</code>,
        the result is <code class="notranslate" translate="no">k</code> when <code class="notranslate" translate="no">k</code> is even, and <code class="notranslate" translate="no">k + 1</code> when <code class="notranslate" translate="no">k</code> is odd.<br> Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn saturate(e: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="saturate-float-builtin"><a href="https://www.w3.org/TR/WGSL/#saturate-float-builtin" target="_blank"></a>Returns <code class="notranslate" translate="no">clamp(e, 0.0, 1.0)</code>. Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn sign(e: T) -&gt; T </pre></td><td>S is AbstractInt, AbstractFloat, i32, f32, or f16T is S, or vecN&lt;S&gt; 
     </td><td id="sign-builtin"><a href="https://www.w3.org/TR/WGSL/#sign-builtin" target="_blank"></a>
       Result is: 
       <ul>
        <li> 1 when <code class="notranslate" translate="no">e</code> &gt; 0 
        </li><li> 0 when <code class="notranslate" translate="no">e</code> = 0 
        </li><li> -1 when <code class="notranslate" translate="no">e</code> &lt; 0 
       </li></ul>
       <p>Component-wise when <code class="notranslate" translate="no">T</code> is a vector.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn sin(e: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="sin-builtin"><a href="https://www.w3.org/TR/WGSL/#sin-builtin" target="_blank"></a>Returns the sine of <code class="notranslate" translate="no">e</code>, where <code class="notranslate" translate="no">e</code> is in radians. Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn sinh(e: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="sinh-builtin"><a href="https://www.w3.org/TR/WGSL/#sinh-builtin" target="_blank"></a>
       Returns the hyperbolic sine of <code class="notranslate" translate="no">e</code>, where <code class="notranslate" translate="no">e</code> is a hyperbolic angle in radians.
    Approximates the pure mathematical function
    (<em>e</em><sup>arg</sup> − <em>e</em><sup>−arg</sup>)÷2,
    but not necessarily computed that way. 
       <p>Component-wise when <code class="notranslate" translate="no">T</code> is a vector.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn smoothstep(low: T, high: T, x: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="smoothstep-builtin"><a href="https://www.w3.org/TR/WGSL/#smoothstep-builtin" target="_blank"></a>
       Returns the smooth Hermite interpolation between 0 and 1. Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
       <p>For scalar <code class="notranslate" translate="no">T</code>, the result is <code class="notranslate" translate="no">t * t * (3.0 - 2.0 * t)</code>,
    where <code class="notranslate" translate="no">t = clamp((x - low) / (high - low), 0.0, 1.0)</code>.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn sqrt(e: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="sqrt-builtin"><a href="https://www.w3.org/TR/WGSL/#sqrt-builtin" target="_blank"></a>Returns the square root of <code class="notranslate" translate="no">e</code>. Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn step(edge: T, x: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="step-builtin"><a href="https://www.w3.org/TR/WGSL/#step-builtin" target="_blank"></a>Returns 1.0 if <code class="notranslate" translate="no">edge</code> ≤ <code class="notranslate" translate="no">x</code>, and 0.0 otherwise. Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn tan(e: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="tan-builtin"><a href="https://www.w3.org/TR/WGSL/#tan-builtin" target="_blank"></a>Returns the tangent of <code class="notranslate" translate="no">e</code>, where <code class="notranslate" translate="no">e</code> is in radians. Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn tanh(e: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="tanh-builtin"><a href="https://www.w3.org/TR/WGSL/#tanh-builtin" target="_blank"></a>
       Returns the hyperbolic tangent of <code class="notranslate" translate="no">e</code>, where <code class="notranslate" translate="no">e</code> is a hyperbolic angle in radians.
    Approximates the pure mathematical function
    (<em>e</em><sup>arg</sup> − <em>e</em><sup>−arg</sup>) ÷ (<em>e</em><sup>arg</sup> + <em>e</em><sup>−arg</sup>)
    but not necessarily computed that way. 
       <p>Component-wise when <code class="notranslate" translate="no">T</code> is a vector.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn transpose(e: matRxC&lt;T&gt;) -&gt; matCxR&lt;T&gt; </pre></td><td>T is AbstractFloat, f32, or f16 
     </td><td id="transpose-builtin"><a href="https://www.w3.org/TR/WGSL/#transpose-builtin" target="_blank"></a>Returns the transpose of <code class="notranslate" translate="no">e</code>. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn trunc(e: T) -&gt; T </pre></td><td>S is AbstractFloat, f32, or f16T is S or vecN&lt;S&gt; 
     </td><td id="trunc-builtin"><a href="https://www.w3.org/TR/WGSL/#trunc-builtin" target="_blank"></a>Returns truncate(<code class="notranslate" translate="no">e</code>), the nearest whole number whose absolute value
    is less than or equal to the absolute value of <code class="notranslate" translate="no">e</code>. Component-wise when <code class="notranslate" translate="no">T</code> is a vector. 
   </td></tr><tr class="data-table-head"><td id="derivative-builtin-functions" colspan="3"><a href="https://www.w3.org/TR/WGSL/#derivative-builtin-functions" target="_blank"></a>Derivative Built-in Functions</td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn dpdx(e: T) -&gt; T </pre></td><td>T is f32 or vecN&lt;f32&gt; 
     </td><td id="dpdx-builtin"><a href="https://www.w3.org/TR/WGSL/#dpdx-builtin" target="_blank"></a>
       Partial derivative of <code class="notranslate" translate="no">e</code> with respect to window x coordinates.
    The result is the same as either <code class="notranslate" translate="no">dpdxFine(e)</code> or <code class="notranslate" translate="no">dpdxCoarse(e)</code>. 
       <p>Returns an indeterminate value if called in non-uniform control flow.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn dpdxCoarse(e: T) -&gt; T </pre></td><td>T is f32 or vecN&lt;f32&gt; 
     </td><td id="dpdxCoarse-builtin"><a href="https://www.w3.org/TR/WGSL/#dpdxCoarse-builtin" target="_blank"></a>
       Returns the partial derivative of <code class="notranslate" translate="no">e</code> with respect to window x coordinates using local differences.
    This may result in fewer unique positions that <code class="notranslate" translate="no">dpdxFine(e)</code>. 
       <p>Returns an indeterminate value if called in non-uniform control flow.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn dpdxFine(e: T) -&gt; T </pre></td><td>T is f32 or vecN&lt;f32&gt; 
     </td><td id="dpdxFine-builtin"><a href="https://www.w3.org/TR/WGSL/#dpdxFine-builtin" target="_blank"></a>
       Returns the partial derivative of <code class="notranslate" translate="no">e</code> with respect to window x coordinates. 
       <p>Returns an indeterminate value if called in non-uniform control flow.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn dpdy(e: T) -&gt; T </pre></td><td>T is f32 or vecN&lt;f32&gt; 
     </td><td id="dpdy-builtin"><a href="https://www.w3.org/TR/WGSL/#dpdy-builtin" target="_blank"></a>
       Partial derivative of <code class="notranslate" translate="no">e</code> with respect to window y coordinates.
    The result is the same as either <code class="notranslate" translate="no">dpdyFine(e)</code> or <code class="notranslate" translate="no">dpdyCoarse(e)</code>. 
       <p>Returns an indeterminate value if called in non-uniform control flow.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn dpdyCoarse(e: T) -&gt; T </pre></td><td>T is f32 or vecN&lt;f32&gt; 
     </td><td id="dpdyCoarse-builtin"><a href="https://www.w3.org/TR/WGSL/#dpdyCoarse-builtin" target="_blank"></a>
       Returns the partial derivative of <code class="notranslate" translate="no">e</code> with respect to window y coordinates using local differences.
    This may result in fewer unique positions that <code class="notranslate" translate="no">dpdyFine(e)</code>. 
       <p>Returns an indeterminate value if called in non-uniform control flow.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn dpdyFine(e: T) -&gt; T </pre></td><td>T is f32 or vecN&lt;f32&gt; 
     </td><td id="dpdyFine-builtin"><a href="https://www.w3.org/TR/WGSL/#dpdyFine-builtin" target="_blank"></a>
       Returns the partial derivative of <code class="notranslate" translate="no">e</code> with respect to window y coordinates. 
       <p>Returns an indeterminate value if called in non-uniform control flow.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn fwidth(e: T) -&gt; T </pre></td><td>T is f32 or vecN&lt;f32&gt; 
     </td><td id="fwidth-builtin"><a href="https://www.w3.org/TR/WGSL/#fwidth-builtin" target="_blank"></a>
       Returns <code class="notranslate" translate="no">abs(dpdx(e)) + abs(dpdy(e))</code>. 
       <p>Returns an indeterminate value if called in non-uniform control flow.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn fwidthCoarse(e: T) -&gt; T </pre></td><td>T is f32 or vecN&lt;f32&gt; 
     </td><td id="fwidthCoarse-builtin"><a href="https://www.w3.org/TR/WGSL/#fwidthCoarse-builtin" target="_blank"></a>
       Returns <code class="notranslate" translate="no">abs(dpdxCoarse(e)) + abs(dpdyCoarse(e))</code>. 
       <p>Returns an indeterminate value if called in non-uniform control flow.</p>
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn fwidthFine(e: T) -&gt; T </pre></td><td>T is f32 or vecN&lt;f32&gt; 
     </td><td id="fwidthFine-builtin"><a href="https://www.w3.org/TR/WGSL/#fwidthFine-builtin" target="_blank"></a>
       Returns <code class="notranslate" translate="no">abs(dpdxFine(e)) + abs(dpdyFine(e))</code>. 
       <p>Returns an indeterminate value if called in non-uniform control flow.</p>
   </td></tr><tr class="data-table-head"><td id="texture-builtin-functions" colspan="3"><a href="https://www.w3.org/TR/WGSL/#texture-builtin-functions" target="_blank"></a>Texture Built-in Functions</td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureDimensions(t: T) -&gt; u32 </pre></td><td>ST is i32, u32, or f32 F is a texel format A is an access mode T is texture_1d&lt;ST&gt; or texture_storage_1d&lt;F,A&gt; 
      </td><td id="texturedimensions"><a href="https://www.w3.org/TR/WGSL/#texturedimensions" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureDimensions(t: T, level: L) -&gt; u32 </pre></td><td>
       ST is i32, u32, or f32 T is texture_1d&lt;ST&gt; 
       L is i32, or u32
      </td><td id="texturedimensions"><a href="https://www.w3.org/TR/WGSL/#texturedimensions" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureDimensions(t: T) -&gt; vec2&lt;u32&gt; </pre></td><td>ST is i32, u32, or f32 F is a texel format A is an access mode T is texture_2d&lt;ST&gt;, texture_2d_array&lt;ST&gt;, texture_cube&lt;ST&gt;, texture_cube_array&lt;ST&gt;, texture_multisampled_2d&lt;ST&gt;, texture_depth_2d, texture_depth_2d_array, texture_depth_cube, texture_depth_cube_array, texture_depth_multisampled_2d, texture_storage_2d&lt;F,A&gt;, texture_storage_2d_array&lt;F,A&gt;,
               or texture_external 
      </td><td id="texturedimensions"><a href="https://www.w3.org/TR/WGSL/#texturedimensions" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureDimensions(t: T, level: L) -&gt; vec2&lt;u32&gt; </pre></td><td>
       ST is i32, u32, or f32 T is texture_2d&lt;ST&gt;, texture_2d_array&lt;ST&gt;, texture_cube&lt;ST&gt;, texture_cube_array&lt;ST&gt;, texture_depth_2d, texture_depth_2d_array, texture_depth_cube, or texture_depth_cube_array 
       L is i32, or u32
      </td><td id="texturedimensions"><a href="https://www.w3.org/TR/WGSL/#texturedimensions" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureDimensions(t: T) -&gt; vec3&lt;u32&gt; </pre></td><td>ST is i32, u32, or f32 F is a texel format A is an access mode T is texture_3d&lt;ST&gt; or texture_storage_3d&lt;F,A&gt; 
      </td><td id="texturedimensions"><a href="https://www.w3.org/TR/WGSL/#texturedimensions" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureDimensions(t: T, level: L) -&gt; vec3&lt;u32&gt; </pre></td><td>
       ST is i32, u32, or f32 T is texture_3d&lt;ST&gt; 
       L is i32, or u32
      </td><td id="texturedimensions"><a href="https://www.w3.org/TR/WGSL/#texturedimensions" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureGather(component: C, t: texture_2d&lt;ST&gt;, s: sampler, coords: vec2&lt;f32&gt;) -&gt; vec4&lt;ST&gt; </pre></td><td>C is i32, or u32 ST is i32, u32, or f32 
      </td><td id="texturegather"><a href="https://www.w3.org/TR/WGSL/#texturegather" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureGather(component: C, t: texture_2d&lt;ST&gt;, s: sampler, coords: vec2&lt;f32&gt;, offset: vec2&lt;i32&gt;) -&gt; vec4&lt;ST&gt; </pre></td><td>C is i32, or u32 ST is i32, u32, or f32 
      </td><td id="texturegather"><a href="https://www.w3.org/TR/WGSL/#texturegather" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureGather(component: C, t: texture_2d_array&lt;ST&gt;, s: sampler, coords: vec2&lt;f32&gt;, array_index: A) -&gt; vec4&lt;ST&gt; </pre></td><td>C is i32, or u32 A is i32, or u32 ST is i32, u32, or f32 
      </td><td id="texturegather"><a href="https://www.w3.org/TR/WGSL/#texturegather" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureGather(component: C, t: texture_2d_array&lt;ST&gt;, s: sampler, coords: vec2&lt;f32&gt;, array_index: A, offset: vec2&lt;i32&gt;) -&gt; vec4&lt;ST&gt; </pre></td><td>C is i32, or u32 A is i32, or u32 ST is i32, u32, or f32 
      </td><td id="texturegather"><a href="https://www.w3.org/TR/WGSL/#texturegather" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureGather(component: C, t: texture_cube&lt;ST&gt;, s: sampler, coords: vec3&lt;f32&gt;) -&gt; vec4&lt;ST&gt; </pre></td><td>C is i32, or u32 ST is i32, u32, or f32 
      </td><td id="texturegather"><a href="https://www.w3.org/TR/WGSL/#texturegather" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureGather(component: C, t: texture_cube_array&lt;ST&gt;, s: sampler, coords: vec3&lt;f32&gt;, array_index: A) -&gt; vec4&lt;ST&gt; </pre></td><td>C is i32, or u32 A is i32, or u32 ST is i32, u32, or f32 
      </td><td id="texturegather"><a href="https://www.w3.org/TR/WGSL/#texturegather" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureGather(t: texture_depth_2d, s: sampler, coords: vec2&lt;f32&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>
      </td><td id="texturegather"><a href="https://www.w3.org/TR/WGSL/#texturegather" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureGather(t: texture_depth_2d, s: sampler, coords: vec2&lt;f32&gt;, offset: vec2&lt;i32&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>
      </td><td id="texturegather"><a href="https://www.w3.org/TR/WGSL/#texturegather" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureGather(t: texture_depth_cube, s: sampler, coords: vec3&lt;f32&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>
      </td><td id="texturegather"><a href="https://www.w3.org/TR/WGSL/#texturegather" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureGather(t: texture_depth_2d_array, s: sampler, coords: vec2&lt;f32&gt;, array_index: A) -&gt; vec4&lt;f32&gt; </pre></td><td>A is i32, or u32 
      </td><td id="texturegather"><a href="https://www.w3.org/TR/WGSL/#texturegather" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureGather(t: texture_depth_2d_array, s: sampler, coords: vec2&lt;f32&gt;, array_index: A, offset: vec2&lt;i32&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>A is i32, or u32 
      </td><td id="texturegather"><a href="https://www.w3.org/TR/WGSL/#texturegather" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureGather(t: texture_depth_cube_array, s: sampler, coords: vec3&lt;f32&gt;, array_index: A) -&gt; vec4&lt;f32&gt; </pre></td><td>A is i32, or u32 
      </td><td id="texturegather"><a href="https://www.w3.org/TR/WGSL/#texturegather" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureGatherCompare(t: texture_depth_2d, s: sampler_comparison, coords: vec2&lt;f32&gt;, depth_ref: f32) -&gt; vec4&lt;f32&gt; </pre></td><td>
      </td><td id="texturegathercompare"><a href="https://www.w3.org/TR/WGSL/#texturegathercompare" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureGatherCompare(t: texture_depth_2d, s: sampler_comparison, coords: vec2&lt;f32&gt;, depth_ref: f32, offset: vec2&lt;i32&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>
      </td><td id="texturegathercompare"><a href="https://www.w3.org/TR/WGSL/#texturegathercompare" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureGatherCompare(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2&lt;f32&gt;, array_index: A, depth_ref: f32) -&gt; vec4&lt;f32&gt; </pre></td><td>A is i32, or u32 
      </td><td id="texturegathercompare"><a href="https://www.w3.org/TR/WGSL/#texturegathercompare" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureGatherCompare(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2&lt;f32&gt;, array_index: A, depth_ref: f32, offset: vec2&lt;i32&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>A is i32, or u32 
      </td><td id="texturegathercompare"><a href="https://www.w3.org/TR/WGSL/#texturegathercompare" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureGatherCompare(t: texture_depth_cube, s: sampler_comparison, coords: vec3&lt;f32&gt;, depth_ref: f32) -&gt; vec4&lt;f32&gt; </pre></td><td>
      </td><td id="texturegathercompare"><a href="https://www.w3.org/TR/WGSL/#texturegathercompare" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureGatherCompare(t: texture_depth_cube_array, s: sampler_comparison, coords: vec3&lt;f32&gt;, array_index: A, depth_ref: f32) -&gt; vec4&lt;f32&gt; </pre></td><td>A is i32, or u32 
      </td><td id="texturegathercompare"><a href="https://www.w3.org/TR/WGSL/#texturegathercompare" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureLoad(t: texture_1d&lt;ST&gt;, coords: C, level: L) -&gt; vec4&lt;ST&gt; </pre></td><td>C is i32, or u32 L is i32, or u32 ST is i32, u32, or f32 
      </td><td id="textureload"><a href="https://www.w3.org/TR/WGSL/#textureload" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureLoad(t: texture_2d&lt;ST&gt;, coords: vec2&lt;C&gt;, level: L) -&gt; vec4&lt;ST&gt; </pre></td><td>C is i32, or u32 L is i32, or u32 ST is i32, u32, or f32 
      </td><td id="textureload"><a href="https://www.w3.org/TR/WGSL/#textureload" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureLoad(t: texture_2d_array&lt;ST&gt;, coords: vec2&lt;C&gt;, array_index: A, level: L) -&gt; vec4&lt;ST&gt; </pre></td><td>C is i32, or u32 A is i32, or u32 L is i32, or u32 ST is i32, u32, or f32 
      </td><td id="textureload"><a href="https://www.w3.org/TR/WGSL/#textureload" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureLoad(t: texture_3d&lt;ST&gt;, coords: vec3&lt;C&gt;, level: L) -&gt; vec4&lt;ST&gt; </pre></td><td>C is i32, or u32 L is i32, or u32 ST is i32, u32, or f32 
      </td><td id="textureload"><a href="https://www.w3.org/TR/WGSL/#textureload" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureLoad(t: texture_multisampled_2d&lt;ST&gt;, coords: vec2&lt;C&gt;, sample_index: S)-&gt; vec4&lt;ST&gt; </pre></td><td>C is i32, or u32 S is i32, or u32 ST is i32, u32, or f32 
      </td><td id="textureload"><a href="https://www.w3.org/TR/WGSL/#textureload" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureLoad(t: texture_depth_2d, coords: vec2&lt;C&gt;, level: L) -&gt; f32 </pre></td><td>C is i32, or u32 L is i32, or u32 
      </td><td id="textureload"><a href="https://www.w3.org/TR/WGSL/#textureload" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureLoad(t: texture_depth_2d_array, coords: vec2&lt;C&gt;, array_index: A, level: L) -&gt; f32 </pre></td><td>C is i32, or u32 A is i32, or u32 L is i32, or u32 
      </td><td id="textureload"><a href="https://www.w3.org/TR/WGSL/#textureload" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureLoad(t: texture_depth_multisampled_2d, coords: vec2&lt;C&gt;, sample_index: S)-&gt; f32 </pre></td><td>C is i32, or u32 S is i32, or u32 
      </td><td id="textureload"><a href="https://www.w3.org/TR/WGSL/#textureload" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureLoad(t: texture_external, coords: vec2&lt;C&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>C is i32, or u32 
      </td><td id="textureload"><a href="https://www.w3.org/TR/WGSL/#textureload" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureNumLayers(t: T) -&gt; u32 </pre></td><td>F is a texel format A is an access mode ST is i32, u32, or f32 T is texture_2d_array&lt;ST&gt;, texture_cube_array&lt;ST&gt;, texture_depth_2d_array, texture_depth_cube_array,
                               or texture_storage_2d_array&lt;F,A&gt; 
      </td><td id="texturenumlayers"><a href="https://www.w3.org/TR/WGSL/#texturenumlayers" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureNumLevels(t: T) -&gt; u32 </pre></td><td>ST is i32, u32, or f32 T is texture_1d&lt;ST&gt;, texture_2d&lt;ST&gt;, texture_2d_array&lt;ST&gt;, texture_3d&lt;ST&gt;, texture_cube&lt;ST&gt;, texture_cube_array&lt;ST&gt;, texture_depth_2d, texture_depth_2d_array, texture_depth_cube, or texture_depth_cube_array 
      </td><td id="texturenumlevels"><a href="https://www.w3.org/TR/WGSL/#texturenumlevels" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureNumSamples(t: T) -&gt; u32 </pre></td><td>ST is i32, u32, or f32 T is texture_multisampled_2d&lt;ST&gt; or texture_depth_multisampled_2d 
      </td><td id="texturenumsamples"><a href="https://www.w3.org/TR/WGSL/#texturenumsamples" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSample(t: texture_1d&lt;f32&gt;, s: sampler, coords: f32) -&gt; vec4&lt;f32&gt; </pre></td><td>
      </td><td id="texturesample"><a href="https://www.w3.org/TR/WGSL/#texturesample" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSample(t: texture_2d&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>
      </td><td id="texturesample"><a href="https://www.w3.org/TR/WGSL/#texturesample" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSample(t: texture_2d&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, offset: vec2&lt;i32&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>
      </td><td id="texturesample"><a href="https://www.w3.org/TR/WGSL/#texturesample" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSample(t: texture_2d_array&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, array_index: A) -&gt; vec4&lt;f32&gt; </pre></td><td>A is i32, or u32 
      </td><td id="texturesample"><a href="https://www.w3.org/TR/WGSL/#texturesample" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSample(t: texture_2d_array&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, array_index: A, offset: vec2&lt;i32&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>A is i32, or u32 
      </td><td id="texturesample"><a href="https://www.w3.org/TR/WGSL/#texturesample" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSample(t: T, s: sampler, coords: vec3&lt;f32&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>T is texture_3d&lt;f32&gt;, or texture_cube&lt;f32&gt; 
      </td><td id="texturesample"><a href="https://www.w3.org/TR/WGSL/#texturesample" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSample(t: texture_3d&lt;f32&gt;, s: sampler, coords: vec3&lt;f32&gt;, offset: vec3&lt;i32&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>
      </td><td id="texturesample"><a href="https://www.w3.org/TR/WGSL/#texturesample" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSample(t: texture_cube_array&lt;f32&gt;, s: sampler, coords: vec3&lt;f32&gt;, array_index: A) -&gt; vec4&lt;f32&gt; </pre></td><td>A is i32, or u32 
      </td><td id="texturesample"><a href="https://www.w3.org/TR/WGSL/#texturesample" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSample(t: texture_depth_2d, s: sampler, coords: vec2&lt;f32&gt;) -&gt; f32 </pre></td><td>
      </td><td id="texturesample"><a href="https://www.w3.org/TR/WGSL/#texturesample" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSample(t: texture_depth_2d, s: sampler, coords: vec2&lt;f32&gt;, offset: vec2&lt;i32&gt;) -&gt; f32 </pre></td><td>
      </td><td id="texturesample"><a href="https://www.w3.org/TR/WGSL/#texturesample" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSample(t: texture_depth_2d_array, s: sampler, coords: vec2&lt;f32&gt;, array_index: A) -&gt; f32 </pre></td><td>A is i32, or u32 
      </td><td id="texturesample"><a href="https://www.w3.org/TR/WGSL/#texturesample" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSample(t: texture_depth_2d_array, s: sampler, coords: vec2&lt;f32&gt;, array_index: A, offset: vec2&lt;i32&gt;) -&gt; f32 </pre></td><td>A is i32, or u32 
      </td><td id="texturesample"><a href="https://www.w3.org/TR/WGSL/#texturesample" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSample(t: texture_depth_cube, s: sampler, coords: vec3&lt;f32&gt;) -&gt; f32 </pre></td><td>
      </td><td id="texturesample"><a href="https://www.w3.org/TR/WGSL/#texturesample" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSample(t: texture_depth_cube_array, s: sampler, coords: vec3&lt;f32&gt;, array_index: A) -&gt; f32 </pre></td><td>A is i32, or u32 
      </td><td id="texturesample"><a href="https://www.w3.org/TR/WGSL/#texturesample" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleBias(t: texture_2d&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, bias: f32) -&gt; vec4&lt;f32&gt; </pre></td><td>
      </td><td id="texturesamplebias"><a href="https://www.w3.org/TR/WGSL/#texturesamplebias" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleBias(t: texture_2d&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, bias: f32, offset: vec2&lt;i32&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>
      </td><td id="texturesamplebias"><a href="https://www.w3.org/TR/WGSL/#texturesamplebias" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleBias(t: texture_2d_array&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, array_index: A, bias: f32) -&gt; vec4&lt;f32&gt; </pre></td><td>A is i32, or u32 
      </td><td id="texturesamplebias"><a href="https://www.w3.org/TR/WGSL/#texturesamplebias" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleBias(t: texture_2d_array&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, array_index: A, bias: f32, offset: vec2&lt;i32&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>A is i32, or u32 
      </td><td id="texturesamplebias"><a href="https://www.w3.org/TR/WGSL/#texturesamplebias" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleBias(t: T, s: sampler, coords: vec3&lt;f32&gt;, bias: f32) -&gt; vec4&lt;f32&gt; </pre></td><td>T is texture_3d&lt;f32&gt;, or texture_cube&lt;f32&gt; 
      </td><td id="texturesamplebias"><a href="https://www.w3.org/TR/WGSL/#texturesamplebias" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleBias(t: texture_3d&lt;f32&gt;, s: sampler, coords: vec3&lt;f32&gt;, bias: f32, offset: vec3&lt;i32&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>
      </td><td id="texturesamplebias"><a href="https://www.w3.org/TR/WGSL/#texturesamplebias" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleBias(t: texture_cube_array&lt;f32&gt;, s: sampler, coords: vec3&lt;f32&gt;, array_index: A, bias: f32) -&gt; vec4&lt;f32&gt; </pre></td><td>A is i32, or u32 
      </td><td id="texturesamplebias"><a href="https://www.w3.org/TR/WGSL/#texturesamplebias" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleCompare(t: texture_depth_2d, s: sampler_comparison, coords: vec2&lt;f32&gt;, depth_ref: f32) -&gt; f32 </pre></td><td>
      </td><td id="texturesamplecompare"><a href="https://www.w3.org/TR/WGSL/#texturesamplecompare" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleCompare(t: texture_depth_2d, s: sampler_comparison, coords: vec2&lt;f32&gt;, depth_ref: f32, offset: vec2&lt;i32&gt;) -&gt; f32 </pre></td><td>
      </td><td id="texturesamplecompare"><a href="https://www.w3.org/TR/WGSL/#texturesamplecompare" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleCompare(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2&lt;f32&gt;, array_index: A, depth_ref: f32) -&gt; f32 </pre></td><td>A is i32, or u32 
      </td><td id="texturesamplecompare"><a href="https://www.w3.org/TR/WGSL/#texturesamplecompare" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleCompare(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2&lt;f32&gt;, array_index: A, depth_ref: f32, offset: vec2&lt;i32&gt;) -&gt; f32 </pre></td><td>A is i32, or u32 
      </td><td id="texturesamplecompare"><a href="https://www.w3.org/TR/WGSL/#texturesamplecompare" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleCompare(t: texture_depth_cube, s: sampler_comparison, coords: vec3&lt;f32&gt;, depth_ref: f32) -&gt; f32 </pre></td><td>
      </td><td id="texturesamplecompare"><a href="https://www.w3.org/TR/WGSL/#texturesamplecompare" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleCompare(t: texture_depth_cube_array, s: sampler_comparison, coords: vec3&lt;f32&gt;, array_index: A, depth_ref: f32) -&gt; f32 </pre></td><td>A is i32, or u32 
      </td><td id="texturesamplecompare"><a href="https://www.w3.org/TR/WGSL/#texturesamplecompare" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleCompareLevel(t: texture_depth_2d, s: sampler_comparison, coords: vec2&lt;f32&gt;, depth_ref: f32) -&gt; f32 </pre></td><td>
      </td><td id="texturesamplecomparelevel"><a href="https://www.w3.org/TR/WGSL/#texturesamplecomparelevel" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleCompareLevel(t: texture_depth_2d, s: sampler_comparison, coords: vec2&lt;f32&gt;, depth_ref: f32, offset: vec2&lt;i32&gt;) -&gt; f32 </pre></td><td>
      </td><td id="texturesamplecomparelevel"><a href="https://www.w3.org/TR/WGSL/#texturesamplecomparelevel" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleCompareLevel(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2&lt;f32&gt;, array_index: A, depth_ref: f32) -&gt; f32 </pre></td><td>A is i32, or u32 
      </td><td id="texturesamplecomparelevel"><a href="https://www.w3.org/TR/WGSL/#texturesamplecomparelevel" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleCompareLevel(t: texture_depth_2d_array, s: sampler_comparison, coords: vec2&lt;f32&gt;, array_index: A, depth_ref: f32, offset: vec2&lt;i32&gt;) -&gt; f32 </pre></td><td>A is i32, or u32 
      </td><td id="texturesamplecomparelevel"><a href="https://www.w3.org/TR/WGSL/#texturesamplecomparelevel" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleCompareLevel(t: texture_depth_cube, s: sampler_comparison, coords: vec3&lt;f32&gt;, depth_ref: f32) -&gt; f32 </pre></td><td>
      </td><td id="texturesamplecomparelevel"><a href="https://www.w3.org/TR/WGSL/#texturesamplecomparelevel" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleCompareLevel(t: texture_depth_cube_array, s: sampler_comparison, coords: vec3&lt;f32&gt;, array_index: A, depth_ref: f32) -&gt; f32 </pre></td><td>A is i32, or u32 
      </td><td id="texturesamplecomparelevel"><a href="https://www.w3.org/TR/WGSL/#texturesamplecomparelevel" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleGrad(t: texture_2d&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, ddx: vec2&lt;f32&gt;, ddy: vec2&lt;f32&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>
      </td><td id="texturesamplegrad"><a href="https://www.w3.org/TR/WGSL/#texturesamplegrad" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleGrad(t: texture_2d&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, ddx: vec2&lt;f32&gt;, ddy: vec2&lt;f32&gt;, offset: vec2&lt;i32&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>
      </td><td id="texturesamplegrad"><a href="https://www.w3.org/TR/WGSL/#texturesamplegrad" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleGrad(t: texture_2d_array&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, array_index: A, ddx: vec2&lt;f32&gt;, ddy: vec2&lt;f32&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>A is i32, or u32 
      </td><td id="texturesamplegrad"><a href="https://www.w3.org/TR/WGSL/#texturesamplegrad" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleGrad(t: texture_2d_array&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, array_index: A, ddx: vec2&lt;f32&gt;, ddy: vec2&lt;f32&gt;, offset: vec2&lt;i32&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>A is i32, or u32 
      </td><td id="texturesamplegrad"><a href="https://www.w3.org/TR/WGSL/#texturesamplegrad" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleGrad(t: T, s: sampler, coords: vec3&lt;f32&gt;, ddx: vec3&lt;f32&gt;, ddy: vec3&lt;f32&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>T is texture_3d&lt;f32&gt;, or texture_cube&lt;f32&gt; 
      </td><td id="texturesamplegrad"><a href="https://www.w3.org/TR/WGSL/#texturesamplegrad" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleGrad(t: texture_3d&lt;f32&gt;, s: sampler, coords: vec3&lt;f32&gt;, ddx: vec3&lt;f32&gt;, ddy: vec3&lt;f32&gt;, offset: vec3&lt;i32&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>
      </td><td id="texturesamplegrad"><a href="https://www.w3.org/TR/WGSL/#texturesamplegrad" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleGrad(t: texture_cube_array&lt;f32&gt;, s: sampler, coords: vec3&lt;f32&gt;, array_index: A, ddx: vec3&lt;f32&gt;, ddy: vec3&lt;f32&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>A is i32, or u32 
      </td><td id="texturesamplegrad"><a href="https://www.w3.org/TR/WGSL/#texturesamplegrad" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleLevel(t: texture_2d&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, level: f32) -&gt; vec4&lt;f32&gt; </pre></td><td>
      </td><td id="texturesamplelevel"><a href="https://www.w3.org/TR/WGSL/#texturesamplelevel" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleLevel(t: texture_2d&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, level: f32, offset: vec2&lt;i32&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>
      </td><td id="texturesamplelevel"><a href="https://www.w3.org/TR/WGSL/#texturesamplelevel" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleLevel(t: texture_2d_array&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, array_index: A, level: f32) -&gt; vec4&lt;f32&gt; </pre></td><td>A is i32, or u32 
      </td><td id="texturesamplelevel"><a href="https://www.w3.org/TR/WGSL/#texturesamplelevel" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleLevel(t: texture_2d_array&lt;f32&gt;, s: sampler, coords: vec2&lt;f32&gt;, array_index: A, level: f32, offset: vec2&lt;i32&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>A is i32, or u32 
      </td><td id="texturesamplelevel"><a href="https://www.w3.org/TR/WGSL/#texturesamplelevel" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleLevel(t: T, s: sampler, coords: vec3&lt;f32&gt;, level: f32) -&gt; vec4&lt;f32&gt; </pre></td><td>T is texture_3d&lt;f32&gt;, or texture_cube&lt;f32&gt; 
      </td><td id="texturesamplelevel"><a href="https://www.w3.org/TR/WGSL/#texturesamplelevel" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleLevel(t: texture_3d&lt;f32&gt;, s: sampler, coords: vec3&lt;f32&gt;, level: f32, offset: vec3&lt;i32&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>
      </td><td id="texturesamplelevel"><a href="https://www.w3.org/TR/WGSL/#texturesamplelevel" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleLevel(t: texture_cube_array&lt;f32&gt;, s: sampler, coords: vec3&lt;f32&gt;, array_index: A, level: f32) -&gt; vec4&lt;f32&gt; </pre></td><td>A is i32, or u32 
      </td><td id="texturesamplelevel"><a href="https://www.w3.org/TR/WGSL/#texturesamplelevel" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleLevel(t: texture_depth_2d, s: sampler, coords: vec2&lt;f32&gt;, level: L) -&gt; f32 </pre></td><td>L is i32, or u32 
      </td><td id="texturesamplelevel"><a href="https://www.w3.org/TR/WGSL/#texturesamplelevel" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleLevel(t: texture_depth_2d, s: sampler, coords: vec2&lt;f32&gt;, level: L, offset: vec2&lt;i32&gt;) -&gt; f32 </pre></td><td>L is i32, or u32 
      </td><td id="texturesamplelevel"><a href="https://www.w3.org/TR/WGSL/#texturesamplelevel" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleLevel(t: texture_depth_2d_array, s: sampler, coords: vec2&lt;f32&gt;, array_index: A, level: L) -&gt; f32 </pre></td><td>A is i32, or u32 L is i32, or u32 
      </td><td id="texturesamplelevel"><a href="https://www.w3.org/TR/WGSL/#texturesamplelevel" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleLevel(t: texture_depth_2d_array, s: sampler, coords: vec2&lt;f32&gt;, array_index: A, level: L, offset: vec2&lt;i32&gt;) -&gt; f32 </pre></td><td>A is i32, or u32 L is i32, or u32 
      </td><td id="texturesamplelevel"><a href="https://www.w3.org/TR/WGSL/#texturesamplelevel" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleLevel(t: texture_depth_cube, s: sampler, coords: vec3&lt;f32&gt;, level: L) -&gt; f32 </pre></td><td>L is i32, or u32 
      </td><td id="texturesamplelevel"><a href="https://www.w3.org/TR/WGSL/#texturesamplelevel" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleLevel(t: texture_depth_cube_array, s: sampler, coords: vec3&lt;f32&gt;, array_index: A, level: L) -&gt; f32 </pre></td><td>A is i32, or u32 L is i32, or u32 
      </td><td id="texturesamplelevel"><a href="https://www.w3.org/TR/WGSL/#texturesamplelevel" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureSampleBaseClampToEdge(t: T, s: sampler, coords: vec2&lt;f32&gt;) -&gt; vec4&lt;f32&gt; </pre></td><td>T is texture_2d&lt;f32&gt; or texture_external 
      </td><td id="textureSampleBaseClampToEdge"><a href="https://www.w3.org/TR/WGSL/#textureSampleBaseClampToEdge" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureStore(t: texture_storage_1d&lt;F,write&gt;, coords: C, value: vec4&lt;CF&gt;) </pre></td><td>F is a texel format C is i32, or u32 CF depends on the storage texel format F. See the texel format table for the mapping of texel
        format to channel format. 
      </td><td id="texturestore"><a href="https://www.w3.org/TR/WGSL/#texturestore" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureStore(t: texture_storage_2d&lt;F,write&gt;, coords: vec2&lt;C&gt;, value: vec4&lt;CF&gt;) </pre></td><td>F is a texel format C is i32, or u32 CF depends on the storage texel format F. See the texel format table for the mapping of texel
        format to channel format. 
      </td><td id="texturestore"><a href="https://www.w3.org/TR/WGSL/#texturestore" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureStore(t: texture_storage_2d_array&lt;F,write&gt;, coords: vec2&lt;C&gt;, array_index: A, value: vec4&lt;CF&gt;) </pre></td><td>F is a texel format C is i32, or u32 A is i32, or u32 CF depends on the storage texel format F. See the texel format table for the mapping of texel
        format to channel format. 
      </td><td id="texturestore"><a href="https://www.w3.org/TR/WGSL/#texturestore" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn textureStore(t: texture_storage_3d&lt;F,write&gt;, coords: vec3&lt;C&gt;, value: vec4&lt;CF&gt;) </pre></td><td>F is a texel format C is i32, or u32 CF depends on the storage texel format F. See the texel format table for the mapping of texel
        format to channel format. 
      </td><td id="texturestore"><a href="https://www.w3.org/TR/WGSL/#texturestore" target="_blank"></a></td></tr><tr class="data-table-head"><td id="atomic-builtin-functions" colspan="3"><a href="https://www.w3.org/TR/WGSL/#atomic-builtin-functions" target="_blank"></a>Atomic Built-in Functions</td></tr><tr><td><pre class="tableprettyprint lang-wgsl">fn atomicLoad(atomic_ptr: ptr&lt;AS, atomic&lt;T&gt;, read_write&gt;) -&gt; T </pre></td><td></td><td id="atomic-load"><a href="https://www.w3.org/TR/WGSL/#atomic-load" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl">fn atomicStore(atomic_ptr: ptr&lt;AS, atomic&lt;T&gt;, read_write&gt;, v: T) </pre></td><td></td><td id="atomic-store"><a href="https://www.w3.org/TR/WGSL/#atomic-store" target="_blank"></a></td></tr><tr><td><pre class="tableprettyprint lang-wgsl">fn atomicAdd(atomic_ptr: ptr&lt;AS, atomic&lt;T&gt;, read_write&gt;, v: T) -&gt; T fn atomicSub(atomic_ptr: ptr&lt;AS, atomic&lt;T&gt;, read_write&gt;, v: T) -&gt; T fn atomicMax(atomic_ptr: ptr&lt;AS, atomic&lt;T&gt;, read_write&gt;, v: T) -&gt; T fn atomicMin(atomic_ptr: ptr&lt;AS, atomic&lt;T&gt;, read_write&gt;, v: T) -&gt; T fn atomicAnd(atomic_ptr: ptr&lt;AS, atomic&lt;T&gt;, read_write&gt;, v: T) -&gt; T fn atomicOr(atomic_ptr: ptr&lt;AS, atomic&lt;T&gt;, read_write&gt;, v: T) -&gt; T fn atomicXor(atomic_ptr: ptr&lt;AS, atomic&lt;T&gt;, read_write&gt;, v: T) -&gt; T </pre></td><td></td><td id="atomic-rmw"><a href="https://www.w3.org/TR/WGSL/#atomic-rmw" target="_blank"></a></td></tr><tr class="data-table-head"><td id="pack-builtin-functions" colspan="3"><a href="https://www.w3.org/TR/WGSL/#pack-builtin-functions" target="_blank"></a>Data Packing Built-in Functions</td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn pack4x8snorm(e: vec4&lt;f32&gt;) -&gt; u32 </pre></td><td></td><td id="pack4x8snorm-builtin"><a href="https://www.w3.org/TR/WGSL/#pack4x8snorm-builtin" target="_blank"></a>Converts four normalized floating point values to 8-bit signed integers, and then combines them
        into one <code class="notranslate" translate="no">u32</code> value.<br> Component <code class="notranslate" translate="no">e[i]</code> of the input is converted to an 8-bit twos complement integer value
        ⌊ 0.5 + 127 × min(1, max(-1, e[i])) ⌋ which is then placed in bits
        8 × <code class="notranslate" translate="no">i</code> through
        8 × <code class="notranslate" translate="no">i</code> + 7 of the result. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn pack4x8unorm(e: vec4&lt;f32&gt;) -&gt; u32 </pre></td><td></td><td id="pack4x8unorm-builtin"><a href="https://www.w3.org/TR/WGSL/#pack4x8unorm-builtin" target="_blank"></a>Converts four normalized floating point values to 8-bit unsigned integers, and then combines them
        into one <code class="notranslate" translate="no">u32</code> value.<br> Component <code class="notranslate" translate="no">e[i]</code> of the input is converted to an 8-bit unsigned integer value
        ⌊ 0.5 + 255 × min(1, max(0, e[i])) ⌋ which is then placed in bits
        8 × <code class="notranslate" translate="no">i</code> through
        8 × <code class="notranslate" translate="no">i</code> + 7 of the result. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn pack2x16snorm(e: vec2&lt;f32&gt;) -&gt; u32 </pre></td><td></td><td id="pack2x16snorm-builtin"><a href="https://www.w3.org/TR/WGSL/#pack2x16snorm-builtin" target="_blank"></a>Converts two normalized floating point values to 16-bit signed integers, and then combines them
        into one <code class="notranslate" translate="no">u32</code> value.<br> Component <code class="notranslate" translate="no">e[i]</code> of the input is converted to a 16-bit twos complement integer value
        ⌊ 0.5 + 32767 × min(1, max(-1, e[i])) ⌋ which is then placed in bits
        16 × <code class="notranslate" translate="no">i</code> through
        16 × <code class="notranslate" translate="no">i</code> + 15 of the result. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn pack2x16unorm(e: vec2&lt;f32&gt;) -&gt; u32 </pre></td><td></td><td id="pack2x16unorm-builtin"><a href="https://www.w3.org/TR/WGSL/#pack2x16unorm-builtin" target="_blank"></a>Converts two normalized floating point values to 16-bit unsigned integers, and then combines them
        into one <code class="notranslate" translate="no">u32</code> value.<br> Component <code class="notranslate" translate="no">e[i]</code> of the input is converted to a 16-bit unsigned integer value
        ⌊ 0.5 + 65535 × min(1, max(0, e[i])) ⌋ which is then placed in bits
        16 × <code class="notranslate" translate="no">i</code> through
        16 × <code class="notranslate" translate="no">i</code> + 15 of the result. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn pack2x16float(e: vec2&lt;f32&gt;) -&gt; u32 </pre></td><td></td><td id="pack2x16float-builtin"><a href="https://www.w3.org/TR/WGSL/#pack2x16float-builtin" target="_blank"></a>
       Converts two floating point values to half-precision floating point numbers, and then combines
        them into one <code class="notranslate" translate="no">u32</code> value.<br> Component <code class="notranslate" translate="no">e[i]</code> of the input is converted to a IEEE-754 binary16 value, which is then
        placed in bits
        16 × <code class="notranslate" translate="no">i</code> through
        16 × <code class="notranslate" translate="no">i</code> + 15 of the result.
        See § 14.6.2 Floating Point Conversion. 
       <p>If either <code class="notranslate" translate="no">e[0]</code> or <code class="notranslate" translate="no">e[1]</code> is outside the finite range of binary16 then:</p>
       <ul>
        <li data-md="">
         <p>It is a shader-creation error if <code class="notranslate" translate="no">e</code> is a const-expression.</p>
        </li><li data-md="">
         <p>It is a pipeline-creation error if <code class="notranslate" translate="no">e</code> is an override-expression.</p>
        </li><li data-md="">
         <p>Otherwise the result is an indeterminate value for u32.</p>
       </li></ul>
   </td></tr><tr class="data-table-head"><td id="unpack-builtin-functions" colspan="3"><a href="https://www.w3.org/TR/WGSL/#unpack-builtin-functions" target="_blank"></a>Data Unpacking Built-in Functions</td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn unpack4x8snorm(e: u32) -&gt; vec4&lt;f32&gt; </pre></td><td></td><td id="unpack4x8snorm-builtin"><a href="https://www.w3.org/TR/WGSL/#unpack4x8snorm-builtin" target="_blank"></a>Decomposes a 32-bit value into four 8-bit chunks, then reinterprets
        each chunk as a signed normalized floating point value.<br> Component <code class="notranslate" translate="no">i</code> of the result is max(v ÷ 127, -1), where <code class="notranslate" translate="no">v</code> is the interpretation of
        bits 8×<code class="notranslate" translate="no">i</code> through 8×<code class="notranslate" translate="no">i + 7</code> of <code class="notranslate" translate="no">e</code> as a twos-complement signed integer. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn unpack4x8unorm(e: u32) -&gt; vec4&lt;f32&gt; </pre></td><td></td><td id="unpack4x8unorm-builtin"><a href="https://www.w3.org/TR/WGSL/#unpack4x8unorm-builtin" target="_blank"></a>Decomposes a 32-bit value into four 8-bit chunks, then reinterprets
        each chunk as an unsigned normalized floating point value.<br> Component <code class="notranslate" translate="no">i</code> of the result is <code class="notranslate" translate="no">v</code> ÷ 255, where <code class="notranslate" translate="no">v</code> is the interpretation of
        bits 8×<code class="notranslate" translate="no">i</code> through 8×<code class="notranslate" translate="no">i + 7</code> of <code class="notranslate" translate="no">e</code> as an unsigned integer. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn unpack2x16snorm(e: u32) -&gt; vec2&lt;f32&gt; </pre></td><td></td><td id="unpack2x16snorm-builtin"><a href="https://www.w3.org/TR/WGSL/#unpack2x16snorm-builtin" target="_blank"></a>Decomposes a 32-bit value into two 16-bit chunks, then reinterprets
        each chunk as a signed normalized floating point value.<br> Component <code class="notranslate" translate="no">i</code> of the result is max(v ÷ 32767, -1), where <code class="notranslate" translate="no">v</code> is the interpretation of
        bits 16×<code class="notranslate" translate="no">i</code> through 16×<code class="notranslate" translate="no">i + 15</code> of <code class="notranslate" translate="no">e</code> as a twos-complement signed integer. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn unpack2x16unorm(e: u32) -&gt; vec2&lt;f32&gt; </pre></td><td></td><td id="unpack2x16unorm-builtin"><a href="https://www.w3.org/TR/WGSL/#unpack2x16unorm-builtin" target="_blank"></a>Decomposes a 32-bit value into two 16-bit chunks, then reinterprets
        each chunk as an unsigned normalized floating point value.<br> Component <code class="notranslate" translate="no">i</code> of the result is <code class="notranslate" translate="no">v</code> ÷ 65535, where <code class="notranslate" translate="no">v</code> is the interpretation of
        bits 16×<code class="notranslate" translate="no">i</code> through 16×<code class="notranslate" translate="no">i + 15</code> of <code class="notranslate" translate="no">e</code> as an unsigned integer. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn unpack2x16float(e: u32) -&gt; vec2&lt;f32&gt; </pre></td><td></td><td id="unpack2x16float-builtin"><a href="https://www.w3.org/TR/WGSL/#unpack2x16float-builtin" target="_blank"></a>Decomposes a 32-bit value into two 16-bit chunks, and reinterpets each chunk
        as a floating point value.<br> Component <code class="notranslate" translate="no">i</code> of the result is the f32 representation of <code class="notranslate" translate="no">v</code>,
        where <code class="notranslate" translate="no">v</code> is the interpretation of bits 16×<code class="notranslate" translate="no">i</code> through 16×<code class="notranslate" translate="no">i + 15</code> of <code class="notranslate" translate="no">e</code> as an IEEE-754 binary16 value.
        See § 14.6.2 Floating Point Conversion. 
   </td></tr><tr class="data-table-head"><td id="sync-builtin-functions" colspan="3"><a href="https://www.w3.org/TR/WGSL/#sync-builtin-functions" target="_blank"></a>Synchronization Built-in Functions</td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn storageBarrier() </pre></td><td></td><td id="storageBarrier-builtin"><a href="https://www.w3.org/TR/WGSL/#storageBarrier-builtin" target="_blank"></a>Executes a control barrier synchronization function that affects
    memory and atomic operations in the storage address
    space. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn workgroupBarrier() </pre></td><td></td><td id="workgroupBarrier-builtin"><a href="https://www.w3.org/TR/WGSL/#workgroupBarrier-builtin" target="_blank"></a>Executes a control barrier synchronization function that affects
    memory and atomic operations in the workgroup address
    space. 
   </td></tr><tr><td><pre class="tableprettyprint lang-wgsl"> fn workgroupUniformLoad(p : ptr&lt;workgroup, T&gt;) -&gt; T </pre></td><td>T is a concrete plain type with a fixed footprint that does not contain any atomic types 
     </td><td id="workgroupUniformLoad-builtin"><a href="https://www.w3.org/TR/WGSL/#workgroupUniformLoad-builtin" target="_blank"></a>
       Returns the value pointed to by <code class="notranslate" translate="no">p</code> to all invocations in the workgroup.
    The return value is uniform. <code class="notranslate" translate="no">p</code> must be a uniform value. 
       <p>Executes a control barrier synchronization function that affects
    memory and atomic operations in the workgroup address
    space.</p>
   </td></tr></tbody></table>
</div>
<!-- keep this at the bottom of the article -->
<script type="module" src="webgpu-wgsl-function-reference.js"></script>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgpu/lessons/webgpu-wgsl-function-reference.html" selected="">English
</option></select>


        <div id="toc">
          <ul>  <li>Basics</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgpu/lessons/webgpu-inter-stage-variables.html">Inter-stage Variables</a></li>
<li><a href="/webgpu/lessons/webgpu-uniforms.html">Uniforms</a></li>
<li><a href="/webgpu/lessons/webgpu-storage-buffers.html">Storage Buffers</a></li>
<li><a href="/webgpu/lessons/webgpu-vertex-buffers.html">Vertex Buffers</a></li>
<li><a href="/webgpu/lessons/webgpu-textures.html">Textures</a></li>
<li><a href="/webgpu/lessons/webgpu-constants.html">Constants</a></li>
<li><a href="/webgpu/lessons/webgpu-memory-layout.html">Data Memory Layout</a></li>
<li><a href="/webgpu/lessons/webgpu-wgsl.html">WGSL</a></li>
<li><a href="/webgpu/lessons/webgpu-how-it-works.html">How It Works</a></li>
        </ul>
  <li>Mics</li>
        <ul>
          <li><a href="/webgpu/lessons/webgpu-from-webgl.html">WebGPU from WebGL</a></li>
<li><a href="/webgpu/lessons/webgpu-resources.html">Resources / References</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/gfxfundamentals/webgpufundamentals">github</a></li>
  <!--<li><a href="https://google.github.io/tour-of-wgsl/">Tour of WGSL</a></li>-->
  <li><a href="https://gpuweb.github.io/types/">WebGPU API Reference</a></li>
  <li><a href="https://www.w3.org/TR/webgpu/">WebGPU Spec</a></li>
  <li><a href="https://www.w3.org/TR/WGSL/">WGSL Spec</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
    <div>Questions? <a href="http://stackoverflow.com/questions/tagged/webgpu">Ask on stackoverflow</a>.</div>
    <div>
       <a href="https://github.com/gfxfundamentals/webgpufundamentals/issues/new?assignees=&amp;labels=suggested+topic&amp;template=suggest-topic.md&amp;title=%5BSUGGESTION%5D">Suggestion</a>?
       <a href="https://github.com/gfxfundamentals/webgpufundamentals/issues/new?assignees=&amp;labels=&amp;template=request.md&amp;title=">Request</a>?
       <a href="https://github.com/gfxfundamentals/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Issue</a>?
       <a href="https://github.com/gfxfundamentals/webgpufundamentals/issues/new?assignees=&amp;labels=bug+%2F+issue&amp;template=bug-issue-report.md&amp;title=">Bug</a>?
    </div>
    <div class="lesson-comment-notes">
       Use <b>&lt;pre&gt;&lt;code&gt;</b>code goes here<b>&lt;/code&gt;&lt;/pre&gt;</b> for code blocks
    </div>
  

        <div id="disqus_thread"></div>
        <script>
            var disqus_config = function () {
              this.page.url = `${window.location.origin}${window.location.pathname}`;
              this.page.identifier = `WGSL Function Reference`;
            };
            (function() { // DON'T EDIT BELOW THIS LINE
                if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
                    return;
                }
                var d = document, s = d.createElement('script');
                s.src = 'https://webgpufundamentals-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>

<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgpufundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/webgpu/lessons/resources/prettify.js"></script>
<script src="/webgpu/lessons/resources/lesson.js"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("webgpufundamentals.org") < 0) {
      return;
  }

  function addScript(src, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }
  /*
  addScript('https://www.googletagmanager.com/gtag/js?id=UA-120733518-1', () => {
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-120733518-1');
  });
  */
}());
</script>






</body></html>