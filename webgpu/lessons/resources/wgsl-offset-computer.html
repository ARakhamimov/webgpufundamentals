<!DOCTYPE html>
<html>
  <head>
    <link href="lesson.css" rel="stylesheet">
    <style>
      :root {
        --error-bg-color: pink;
        --divider-bg-color: #8cb5ff;
      }
      @media (prefers-color-scheme: dark) {
        :root {
          --error-bg-color: darkred;
          --divider-bg-color: #33f;
        }
      }
      html, body {
        margin: 0;
        height: 100%;
        font-family: monospace;
      }
      button {
        font-family: monospace;
      }
      #frame {
        height: 100%;
        display: flex;
        flex-direction: column;
      }
      #header {
        flex: 0 0 auto;
        padding: 0.25em;
        background-color: var(--divider-bg-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      #header a {
        /* makes it center */
        display: flex;
      }
      #github {
        display: flex;
        align-items: center;
      }
      #workarea {
        flex: 1 1 auto;
        min-height: 0;
      }
      #split {
        display: flex;
        height: 100%;
      }
      .h-sep,
      .v-sep {
        flex: 0 0 5px;
        background-color: var(--divider-bg-color);
      }
      #left {
        flex: 1 1 50%;
        min-height: 0;
      }
      #editor {
        height: 100%;
      }
      #right {
        flex: 1 1 50%;
        min-height: 0;
        display: flex;
        flex-direction: column;
      }
      #ui-split {
        display: flex;
      }
      .ui-area {
        padding: 1em;
      }
      #ui {
        flex: 0 0 auto;
        font-size: medium;
        line-height: 1.5;
      }
      #output {
        flex: 1 1 auto;
        min-height: 0;
        overflow: auto;
      }
      #diagram {
        padding: 1em;
      }
      #errors {
        font-size: small;
        padding: 1em;
      }
      pre {
        margin: 0;
      }
      .icon {
        width: 1em;
      }
      .nowrap {
        white-space: nowrap;
      }
      label {
        display: inline-flex;
        align-items: center;
      }
      label:has([disabled]) {
        opacity: 50%;
      }
      .wgslError {
        background-color: var(--error-bg-color);
      }

      /* remove? this is overriding lesson.css. Maybe we should remove lesson.css */
      pre.prettyprint {
        border: none;
        box-shadow: none;
        margin-top: 0 !important;
        margin-bottom: 0 !important;
      }
      @media (prefers-color-scheme: light) {
        pre.prettyprint {
          filter: invert(1) brightness(1.2);
        }
      }

    </style>
  </head>
  <body>
    <div id="frame">
      <div id="header">
        <div>wgsl offset computer</div>
        <div id="github"><a href="https://github.com/gfxfundamentals/webgpufundamentals" target="_blank"><img class="icon" src="octocat-icon.svg"></a></div>
      </div>
      <div id="workarea">
        <div id="split">
          <div id="left">
            <div id="editor"></div>
          </div>
          <div class="v-sep"></div>
          <div id="right">
               <div id="ui">
                 <div id="ui-split">
                  <div class="ui-area nowrap">
                    <div>
                      <label><input id="compile" type="checkbox" checked>Compile Shader (finds errors)<span id="compile-status" style="display: none;">[needs WebGPU]<span></span></label>
                    </div>
                    <div>
                      <label><input name="style" type="radio" value="views" checked>as views</label>
                      <label><input name="style" type="radio" value="offsets">as offsets</label>
                    </div>
                    <div>
                      <button type="button" id="process">Process</button>
                    </div>
                  </div>
                  <div class="v-sep"></div>
                  <div class="ui-area">
                    This site is useful for <a href="https://webgpufundamentals.org/webgpu/lessons/webgpu-memory-layout.html">understanding WGSL offsets</a>
                    but you should arguably <a href="https://github.com/greggman/webgpu-utils">use a library</a>
                    rather than hardcode things.
                  </div>
                </div>
              </div>
              <div class="h-sep"></div>
              <div id="output">
                <div id="errors"></div>
                <pre id="results"></pre>
                <div id="diagram"></div>
              </div>
        </div>
      </div>
    </div>
  </div>
    <script src="/monaco-editor/min/vs/loader.js"></script>
    <script src="prettify.js"></script>
    <script src="/3rdparty/lzma.js"></script>
    <script type="module">
/* global monaco */
/* global LZMA */
import {
  makeShaderDataDefinitions,
} from '/3rdparty/webgpu-utils.module.js';
import {
  createByteDiagramForType,
  getCodeForUniform,
} from './data-byte-diagram.js';
import { createElem as el } from './elem.js';
import {
  convertHexToBytes,
  convertBytesToHex,
} from './utils.js';
const compressor = new LZMA('/3rdparty/lzma_worker.js');

const examples = {
  basic: `
    struct VSInput {
      projectionMatrix: mat4x4f,
      viewMatrix: mat4x4f,
      modelMatrix: mat4x4f,
      normalMatrix: mat4x4f,
    };

    struct Light {
      mode: u32,
      power: f32,
      range: f32,
      innerAngle: f32,
      outerAngle: f32,
      direction: vec3f,
      position: vec3f,
    };

    struct FSInput {
      colorMult: vec4f,
      specularFactor: f32,
      lights: array<Light, 2>,
    };

    @group(0) @binding(0) var<uniform> vsUni: VSInput;
    @group(0) @binding(1) var<uniform> fsUni: FSInput;
    @group(0) @binding(2) var diffuseSampler: sampler;
    @group(0) @binding(3) var diffuseTexture: texture_2d<f32>;

    struct Attribs {
      @location(0) position: vec4f,
      @location(1) normal: vec3f,
      @location(2) texcoord: vec2f,
    };

    struct VSOutput {
      @builtin(position) position: vec4f,
      @location(0) texcoord: vec2f,
      @location(1) normal: vec3f,
    };

    @vertex fn vs(vin: Attribs) -> VSOutput {
      var vout: VSOutput;
      vout.position = vsUni.projectionMatrix * vsUni.viewMatrix * vsUni.modelMatrix * vin.position;
      vout.texcoord = vin.texcoord;
      vout.normal = (vsUni.normalMatrix * vec4f(vin.normal, 0)).xyz;
      return vout;
    }

    @fragment fn fs(vout: VSOutput) -> @location(0) vec4f {
      let normal = normalize(vout.normal);
      var l = 0.0;
      for (var i = 0; i < 2; i++) {
        let light = fsUni.lights[i];
        l += clamp(dot(normal, light.direction), 0.0, 1.0);
      }

      let color = textureSample(diffuseTexture, diffuseSampler, vout.texcoord);
      return vec4f(color.rgb * clamp(l, 0.0, 1.0), color.a);
    }
  `,
};

const darkMatcher = window.matchMedia('(prefers-color-scheme: dark)');
const isDarkMode = darkMatcher.matches;

const resultsElem = document.querySelector('#results');
const diagramElem = document.querySelector('#diagram');
const errorsElem = document.querySelector('#errors');
const compileElem = document.querySelector('#compile');

function clearResults() {
  resultsElem.innerHTML = '';
  diagramElem.innerHTML = '';
  errorsElem.innerHTML = '';
  resultsElem.className = 'prettyprint';
}

let updateURL = false;
function updateResults(code, style) {
  try {
    const defs = makeShaderDataDefinitions(code);

    const results = [];
    for (const key of ['uniforms', 'storages']) {
      for (const [name, uniform] of Object.entries(defs[key])) {
        diagramElem.appendChild(el('p', { textContent: name }));
        diagramElem.appendChild(createByteDiagramForType(name, uniform));
        diagramElem.appendChild(el('hr'));
        results.push(getCodeForUniform(name, uniform, style));
      }
    }
    resultsElem.textContent = results.join('\n\n');
    window.prettyPrint(resultsElem);

    if (updateURL) {
      const save = JSON.stringify({
        c: compileElem.checked ? 1 : 0,
        x: code,
      });
      compressor.compress(save, 1, function(bytes) {
        const hex = convertBytesToHex(bytes);
        const params = new URLSearchParams({x: hex});
        window.location.replace(`#${params.toString()}`);
      },
      () => { /* */ });
    }
    updateURL = true;
  } catch (e) {
    errorsElem.appendChild(el(
      'div',
      {},
      [
        el('div', {textContent: `wgsl errors: ${e}`}),
      ],
    ));

  }
}

/* global require */
require.config({ paths: { 'vs': '/monaco-editor/min/vs' }});
require(['vs/editor/editor.main'], () => {
  const editor = monaco.editor.create(document.querySelector('#editor'), {
    value: examples.basic,
    language: 'wgsl',
    automaticLayout: true,
    lineNumbers: true,
    theme: isDarkMode ? 'vs-dark' : 'vs-light',
    disableTranslate3d: true,
    //   model: null,
    scrollBeyondLastLine: false,
    minimap: { enabled: false },
  });
  main(editor);
});

async function main(editor) {
  function readURL(hash) {
    const data = Object.fromEntries(new URLSearchParams(hash[0] === '#' ? hash.substring(1) : hash).entries());
    console.log('h0', data);
    if (data.x) {
      console.log('h1');
      const bytes = convertHexToBytes(data.x);
      compressor.decompress(
        bytes,
        (text) => {
          console.log('h2');
          const data = JSON.parse(text);
          compileElem.checked = !!data.c;
          editor.setValue(data.x);
          console.log(data.x);
          process();
        },
        () => { /* */ });
    }
  }
  readURL(window.location.hash);

  const adapter = await navigator.gpu?.requestAdapter();
  const device = await adapter?.requestDevice({
    requiredLimits: adapter.limits,
    //requiredFeatures: adapter.features,
  });

  const compileStatusElem = document.querySelector('#compile-status');
  if (!device) {
    compileStatusElem.style.display = '';
    compileElem.disabled = true;
    compileElem.checked = false;
  }

  const processElem = document.querySelector('#process');
  processElem.addEventListener('click', process);

  let decorations;

  async function process() {
    clearResults();
    if (decorations) {
      decorations.clear();
      decorations = undefined;
    }

    const code = editor.getValue();
    if (compileElem.checked && device) {
      const module = device.createShaderModule({code});
      const info = await module.getCompilationInfo();
      const hasErrors = info.messages?.reduce((err, msg) => err || msg.type === 'error', false);
      if (hasErrors) {
        const errors = info.messages
          .filter(msg => msg.linePos && msg.lineNum && msg.length)
          .map(msg => ({
            range: new monaco.Range(msg.lineNum, msg.linePos, msg.lineNum, msg.linePos + msg.length),
            options: { inlineClassName: 'wgslError' },
          }));
        if (errors.length) {
          decorations = editor.createDecorationsCollection(errors);
          const firstError = info.messages[0];
          editor.setPosition({
            lineNumber: firstError.lineNum,
            column: firstError.linePos,
          });
          editor.revealLineInCenterIfOutsideViewport(firstError.lineNum);
          editor.focus();
        }
        errorsElem.appendChild(el(
          'div',
          {},
          [
            el('div', {textContent: 'wgsl errors:'}),
            ...info.messages.map(msg => el('div', {textContent: `${msg.lineNum || 0}:${msg.linePos || 0}: ${msg.message}`})),
          ],
        ));
        return;
      }
    }

    const style = document.querySelector('input[name=style]:checked').value;
    updateResults(code, style);
  }
  process();
}

    </script>
  </body>
</html>
