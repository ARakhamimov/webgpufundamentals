<!DOCTYPE html>
<html>
  <head>
    <title>WebGPU Compute Shaders - Histogram, optimized more</title>
    <style>
      @import url(resources/webgpu-lesson.css);
      img {
        max-width: 256px;
      }
      canvas {
        display: block;
        border: 1px solid #888;
      }
    </style>
  </head>
  <body>
  </body>
  <script type="module">
import {createTextureFromSource} from '../3rdparty/webgpu-utils.module.js';

async function main() {
  const adapter = await navigator.gpu?.requestAdapter();
  const device = await adapter?.requestDevice({
    requiredLimits: {
      maxBufferSize: 1024 * 1024 * 1024,
      maxStorageBufferBindingSize: 1024 * 1024 * 1024,
    },
  });
  if (!device) {
    fail('need a browser that supports WebGPU');
    return;
  }

  const k = {
    chunkWidth: 256,
    chunkHeight: 1,
  };
  const chunkSize = k.chunkWidth * k.chunkHeight;
  const sharedConstants = Object.entries(k).map(([k, v]) => `const ${k} = ${v};`).join('\n');

  const histogramChunkModule = device.createShaderModule({
    label: 'histogram chunk shader',
    code: `
      ${sharedConstants}
      const chunkSize = chunkWidth * chunkHeight;
      var<workgroup> histogram: array<array<atomic<u32>, 4>, chunkSize>;
      @group(0) @binding(0) var<storage, read_write> histogramChunks: array<array<vec4u, chunkSize>>;
      @group(0) @binding(1) var ourTexture: texture_2d<f32>;

      const kSRGBLuminanceFactors = vec3f(0.2126, 0.7152, 0.0722);
      fn srgbLuminance(color: vec3f) -> f32 {
        return saturate(dot(color, kSRGBLuminanceFactors));
      }

      @compute @workgroup_size(chunkWidth, chunkHeight, 1)
      fn cs(
        @builtin(workgroup_id) workgroup_id: vec3u,
        @builtin(local_invocation_id) local_invocation_id: vec3u,
      ) {
        let size = textureDimensions(ourTexture, 0);
        let position = workgroup_id.xy * vec2u(chunkWidth, chunkHeight) + 
                       local_invocation_id.xy;
        if (all(position < size)) {
          let numBins = f32(chunkSize);
          let lastBinIndex = u32(numBins - 1);
          var channels = textureLoad(ourTexture, position, 0);
          channels.w = srgbLuminance(channels.rgb);
          for (var ch = 0; ch < 4; ch++) {
            let bin = min(u32(channels[ch] * numBins), lastBinIndex);
            atomicAdd(&histogram[bin][ch], 1u);
          }
        }

        workgroupBarrier();

        let chunksAcross = (size.x + chunkWidth - 1) / chunkWidth;
        let chunk = workgroup_id.y * chunksAcross + workgroup_id.x;
        let bin = local_invocation_id.y * chunkWidth + local_invocation_id.x;

        histogramChunks[chunk][bin] = vec4u(
          atomicLoad(&histogram[bin][0]),
          atomicLoad(&histogram[bin][1]),
          atomicLoad(&histogram[bin][2]),
          atomicLoad(&histogram[bin][3]),
        );
      }
    `,
  });

  // 0,1 => 0    2,3 => 2    4,5 => 4    6,7 ==> 6
  // 0,2 => 0                4,6 => 4
  // 0,4 => 0

  // 0 1 2 3 4 5 6
  // 01  23  45  6
  // 0123    456
  // 0123456

  // 0 1 2 3 4 5
  // 01  23  45
  // 0123    45
  // 0123456

  const chunkSumModule = device.createShaderModule({
    label: 'chunk sum shader',
    code: `
      ${sharedConstants}
      const chunkSize = chunkWidth * chunkHeight;

      struct Uniforms {
        stride: u32,
      };

      @group(0) @binding(0) var<storage, read_write> histogramChunks: array<array<vec4u, chunkSize>>;
      @group(0) @binding(1) var<uniform> uni: Uniforms;

      @compute @workgroup_size(chunkSize, 1, 1) fn cs(
        @builtin(local_invocation_id) local_invocation_id: vec3u,
        @builtin(workgroup_id) workgroup_id: vec3u,
      ) {
        var sum = vec4u(0);
        let chunk0 = workgroup_id.x * uni.stride * 2;
        let chunk1 = chunk0 + uni.stride;

        histogramChunks[chunk0][local_invocation_id.x] =
            histogramChunks[chunk0][local_invocation_id.x] +
            histogramChunks[chunk1][local_invocation_id.x];
      }
    `,
  });


  const histogramChunkPipeline = device.createComputePipeline({
    label: 'histogram',
    layout: 'auto',
    compute: {
      module: histogramChunkModule,
      entryPoint: 'cs',
    },
  });

  const chunkSumPipeline = device.createComputePipeline({
    label: 'chunk sum',
    layout: 'auto',
    compute: {
      module: chunkSumModule,
      entryPoint: 'cs',
    },
  });

  const img = new Image();
  img.crossOrigin = '*';
  img.src = 'resources/images/pexels-francesco-ungaro-96938-mid.jpg'; /* webgpufundamentals: url */
  await img.decode();

  // Add it to the document so we can see it
  document.body.appendChild(img);

  // Upload the image into a texture.
  const imgBitmap = await createImageBitmap(img, { colorSpaceConversion: 'none' });
  const texture = createTextureFromSource(device, imgBitmap);

  //const histogramBuffer = device.createBuffer({
  //  size: 256 * 4 * 4, // 256 entries * 4 (rgba) * 4 bytes per (u32)
  //  usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
  //});

  const chunksAcross = Math.ceil(texture.width / k.chunkWidth);
  const chunksDown = Math.ceil(texture.height / k.chunkHeight);
  const numChunks = chunksAcross * chunksDown;
  console.log('numChunks', numChunks, 'chunksAcross:', chunksAcross, 'chunksDown:', chunksDown);
  console.log('width:', texture.width, 'height:', texture.height, 'numPixels:', texture.width * texture.height);
  const histogramChunksBuffer = device.createBuffer({
    size: numChunks * chunkSize * 4 * 4,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
  });

  const resultBuffer = device.createBuffer({
    size: chunkSize * 4 * 4,
    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
  });

  const histogramBindGroup = device.createBindGroup({
    layout: histogramChunkPipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: histogramChunksBuffer }},
      { binding: 1, resource: texture.createView() },
    ],
  });

  const sumBindGroups = [];
  // -25
  // a b c d e f g h i j k l m n o p q r s t u v w x y  25 (dispatch = 12)
  // ab  cd  ef  gh  ij  kl  mn  op  qr  st  uv  wx  y  13 (dispatch = 6)
  // abcd    efgh    ijkl    mnop    qrst    uvwx    y   7 (dispatch = 3)
  // abcdefgh        ijklmnop        qrstuvwx        y   4 (dispatch = 2)
  // abcedfghijklmnop                qrstuvwxy           4 (dispatch = 1)
  // all

  // -8
  // 4 2 1
  // -7      01 23 45
  // 3 2 1
  // -6
  // 3 2 1
  // -5
  // 2 2 1
  // -4
  // 2 1

  for (let i = 0; ; ++i) {
    const stride = 2 ** i;
    if (stride >= numChunks) {
      break;
    }
    console.log(i, 'stride:', stride);

    const uniformBuffer = device.createBuffer({
      size: 4,
      usage: GPUBufferUsage.UNIFORM,
      mappedAtCreation: true,
    });
    new Uint32Array(uniformBuffer.getMappedRange()).set([stride]);
    uniformBuffer.unmap();

    const chunkSumBindGroup = device.createBindGroup({
      layout: chunkSumPipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: histogramChunksBuffer }},
        { binding: 1, resource: { buffer: uniformBuffer }},
      ],
    });
    sumBindGroups.push(chunkSumBindGroup);
  }

  const encoder = device.createCommandEncoder({ label: 'histogram encoder' });

  {
    const pass = encoder.beginComputePass(encoder);
    pass.setPipeline(histogramChunkPipeline);
    pass.setBindGroup(0, histogramBindGroup);
    pass.dispatchWorkgroups(chunksAcross, chunksDown);
    pass.end();
  }

  {
    const pass = encoder.beginComputePass(encoder);
    pass.setPipeline(chunkSumPipeline);
    let chunksLeft = numChunks;
    sumBindGroups.forEach((bindGroup, i) => {
      pass.setBindGroup(0, bindGroup);
      const dispatchCount = Math.floor(chunksLeft / 2);
      chunksLeft -= dispatchCount;
      // 25 / 2 = 12
      // 13 / 2 = 6
      //  7 / 2 = 3
      //  4 / 2 = 2
      //  2 / 2 = 1
      console.log(i, 'dispatch:', dispatchCount);
      pass.dispatchWorkgroups(dispatchCount);
    });
    pass.end();
  }

  encoder.copyBufferToBuffer(histogramChunksBuffer, 0, resultBuffer, 0, resultBuffer.size);

  const commandBuffer = encoder.finish();
  device.queue.submit([commandBuffer]);

  await resultBuffer.mapAsync(GPUMapMode.READ);
  const histogram = new Uint32Array(resultBuffer.getMappedRange());

  // draw the red, green, and blue channels
  drawHistogram(histogram, [0, 1, 2]);

  // draw the luminosity channel
  drawHistogram(histogram, [3]);

  resultBuffer.unmap();
}

function drawHistogram(histogram, channels, height = 100) {
  // find the highest value for each channel
  const max = [0, 0, 0, 0];
  const total = [0, 0, 0, 0];
  histogram.forEach((v, i) => {
    const ch = i % 4;
    max[ch] = Math.max(max[ch], v);
    total[ch] += v;
  });
  console.log('total:', total);

  const numBins = histogram.length / 4;
  const canvas = document.createElement('canvas');
  canvas.width = numBins;
  canvas.height = height;
  document.body.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  const colors = [
    'rgb(255, 0, 0)',
    'rgb(0, 255, 0)',
    'rgb(0, 0, 255)',
    'rgb(255, 255, 255)',
  ];

  ctx.globalCompositeOperation = 'screen';

  for (let x = 0; x < numBins; ++x) {
    const offset = x * 4;
    for (const ch of channels) {
      const scale = 0.2 * numBins / total[ch];
      const v = histogram[offset + ch] * scale * height;
      ctx.fillStyle = colors[ch];
      ctx.fillRect(x, height - v, 1, v);
    }
  }
}

function fail(msg) {
  // eslint-disable-next-line no-alert
  alert(msg);
}

main();
  </script>
</html>
